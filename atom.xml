<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小孜</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-09T13:16:25.660Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Subminum</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NMAP</title>
    <link href="http://yoursite.com/2018/04/06/nmap/"/>
    <id>http://yoursite.com/2018/04/06/nmap/</id>
    <published>2018-04-05T16:00:00.000Z</published>
    <updated>2018-04-09T13:16:25.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网段上有哪些主机是存活的"><a href="#网段上有哪些主机是存活的" class="headerlink" title="网段上有哪些主机是存活的"></a>网段上有哪些主机是存活的</h2><p>nmap -sP 192.168.0.0/24        （192.168.0.*）</p><h2 id="主机开放了哪些端口"><a href="#主机开放了哪些端口" class="headerlink" title="主机开放了哪些端口"></a>主机开放了哪些端口</h2><p>nmap -sT 192.168.0.0</p><h2 id="隐藏扫描"><a href="#隐藏扫描" class="headerlink" title="隐藏扫描"></a>隐藏扫描</h2><p>nmap -sS 192.168.0.0</p><h2 id="开放了哪些UDP端口"><a href="#开放了哪些UDP端口" class="headerlink" title="开放了哪些UDP端口"></a>开放了哪些UDP端口</h2><p>nmap -sU 192.168.0.0</p><h2 id="操作系统识别"><a href="#操作系统识别" class="headerlink" title="操作系统识别"></a>操作系统识别</h2><p>nmap -sS -O  192.168.0.0</p><h2 id="扫描指定的端口"><a href="#扫描指定的端口" class="headerlink" title="扫描指定的端口"></a>扫描指定的端口</h2><p>nmap -n –open -p 端口号 IP</p><h2 id="确定目标机支持哪些IP协议-TCP，ICMP，IGMP等"><a href="#确定目标机支持哪些IP协议-TCP，ICMP，IGMP等" class="headerlink" title="确定目标机支持哪些IP协议 (TCP，ICMP，IGMP等):"></a>确定目标机支持哪些IP协议 (TCP，ICMP，IGMP等):</h2><p>nmap -sO 192.168.0.0</p><h1 id="netstat-an"><a href="#netstat-an" class="headerlink" title="netstat -an"></a><strong>netstat -an</strong></h1>]]></content>
    
    <summary type="html">
    
      NMAP常用指令
    
    </summary>
    
      <category term="CTF" scheme="http://yoursite.com/categories/CTF/"/>
    
    
      <category term="NMAP" scheme="http://yoursite.com/tags/NMAP/"/>
    
      <category term="CTF" scheme="http://yoursite.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Javascript</title>
    <link href="http://yoursite.com/2018/04/01/JavaScript/"/>
    <id>http://yoursite.com/2018/04/01/JavaScript/</id>
    <published>2018-03-31T16:00:00.000Z</published>
    <updated>2018-04-09T13:16:02.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1>]]></content>
    
    <summary type="html">
    
      面试专用
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="面经" scheme="http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS前端面试</title>
    <link href="http://yoursite.com/2018/03/30/JS%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2018/03/30/JS前端面试/</id>
    <published>2018-03-29T16:00:00.000Z</published>
    <updated>2018-04-09T13:28:22.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//100</span></span><br></pre></td></tr></table></figure><h2 id="引用类型——对象、数组、函数"><a href="#引用类型——对象、数组、函数" class="headerlink" title="引用类型——对象、数组、函数"></a>引用类型——对象、数组、函数</h2><p>变量相当于一个指针</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">age</span>: <span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">b.age = <span class="number">21</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.age);  <span class="comment">//21</span></span><br></pre></td></tr></table></figure><h2 id="typeof——6种类型"><a href="#typeof——6种类型" class="headerlink" title="typeof——6种类型"></a>typeof——6种类型</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'abc'</span> <span class="comment">//string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span> <span class="comment">//number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">//boolean</span></span><br><span class="line"><span class="comment">//typeof 只能区分上面这4种类型</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">//object</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">//object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">//object  引用类型</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log() <span class="comment">//function</span></span><br></pre></td></tr></table></figure><h2 id="变量计算——强制类型转换"><a href="#变量计算——强制类型转换" class="headerlink" title="变量计算——强制类型转换"></a>变量计算——强制类型转换</h2><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span> + <span class="number">10</span>; <span class="comment">//110</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">100</span> + <span class="string">'10'</span>;<span class="comment">//'10010'</span></span><br></pre></td></tr></table></figure><h3 id="运算符"><a href="#运算符" class="headerlink" title="==运算符"></a>==运算符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> == <span class="string">'100'</span> <span class="comment">//true   转化为字符串</span></span><br><span class="line"><span class="number">0</span> == <span class="string">''</span> <span class="comment">//true   转化为false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">//true   转化为false</span></span><br></pre></td></tr></table></figure><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = ture;</span><br><span class="line"><span class="keyword">if</span>(a)&#123;</span><br><span class="line">  <span class="comment">//-&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>(b)&#123;</span><br><span class="line">  <span class="comment">//转化为boolean true 运行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span>(c)&#123;</span><br><span class="line">  <span class="comment">//转化为boolean false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">10</span> &amp;&amp; <span class="number">0</span>); <span class="comment">//0  10-&gt;true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">''</span> || <span class="string">'abc'</span>); <span class="comment">//'abc' ''-&gt;false</span></span><br><span class="line"><span class="built_in">console</span>.log(!windows.abc); <span class="comment">//ture windows.abc-&gt;undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如何检测被强制转换成什么——&gt;加！！</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(!!a);</span><br></pre></td></tr></table></figure><h2 id="何时使用-与"><a href="#何时使用-与" class="headerlink" title="何时使用==与==="></a>何时使用==与===</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj.a == NULL)&#123;</span><br><span class="line">  <span class="comment">//相当于obj.a === null || obj.a ===undefined 的简写形式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="js内置函数——数据封装类对象"><a href="#js内置函数——数据封装类对象" class="headerlink" title="js内置函数——数据封装类对象"></a>js内置函数——数据封装类对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">object</span><br><span class="line"><span class="built_in">Array</span></span><br><span class="line"><span class="built_in">Boolean</span></span><br><span class="line"><span class="built_in">Number</span></span><br><span class="line"><span class="built_in">String</span></span><br><span class="line"><span class="built_in">Function</span></span><br><span class="line"><span class="built_in">Date</span></span><br><span class="line"><span class="built_in">RegExp</span></span><br><span class="line"><span class="built_in">Error</span></span><br></pre></td></tr></table></figure><h2 id="js按存储方式区分变量类型"><a href="#js按存储方式区分变量类型" class="headerlink" title="js按存储方式区分变量类型"></a>js按存储方式区分变量类型</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//值类型</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">age</span>: <span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">b.age = <span class="number">21</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.age);  <span class="comment">//21</span></span><br><span class="line"><span class="comment">//引用类型</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">age</span>: <span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">b.age = <span class="number">21</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.age);  <span class="comment">//21</span></span><br></pre></td></tr></table></figure><h2 id="json只是js的一个内置对象"><a href="#json只是js的一个内置对象" class="headerlink" title="json只是js的一个内置对象"></a>json只是js的一个内置对象</h2>]]></content>
    
    <summary type="html">
    
      JS面试知识点
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="面经" scheme="http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>HTTP&amp;&amp;URL输入后的反应</title>
    <link href="http://yoursite.com/2018/03/28/Http/"/>
    <id>http://yoursite.com/2018/03/28/Http/</id>
    <published>2018-03-27T16:00:00.000Z</published>
    <updated>2018-04-09T13:16:21.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="http全过程"><a href="#http全过程" class="headerlink" title="http全过程"></a>http全过程</h1><p>输入域名(url)–&gt;DNS映射为IP–&gt;TCP三次握手–&gt;HTTP请求–&gt;HTTP响应–&gt;(浏览器跟踪重定向地址)–&gt;服务器处理请求–&gt;服务器返回一个html响应–&gt;(视情况决定释放TCP连接)–&gt;客户端解析HTML–&gt;获取嵌入在HTML中的对象重新发起http请求</p><h2 id="输入域名-url"><a href="#输入域名-url" class="headerlink" title="输入域名(url)"></a>输入域名(url)</h2><p>在域名这里有很多可以聊的：<br><strong>域名级数判别</strong><br><a href="https://books.google.com/books?id=aEYuuKOzktAC&amp;pg=PA263&amp;lpg=PA263&amp;dq=%E4%B8%80%E7%BA%A7%E5%9F%9F%E5%90%8D+www%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D&amp;source=bl&amp;ots=vdMaKdL0PZ&amp;sig=rpDqhUVq3bzz0zscWMrEIhxa6dE&amp;hl=zh-CN&amp;sa=X&amp;ved=0ahUKEwifrsOHiLHPAhWBE5QKHbb9AnAQ6AEIPDAE#v=onepage&amp;q=%E4%B8%80%E7%BA%A7%E5%9F%9F%E5%90%8D%20www%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D&amp;f=false" target="_blank" rel="noopener">域名服务器及域名</a>这里有详细解释，即“计算机网络技术”的第九章Domain Name System<br>一个点分隔一级（域名由分量组成，一级为一个分量），通俗易懂如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...三级域名.二级域名.顶级域名</span><br><span class="line">WWW.baidu.com  com为顶级域名(通常依据组织和地理分为两类)，baidu为二级域名，WWW网站</span><br><span class="line">www.pic.baidu.com pic为三级域名</span><br><span class="line">所谓降域，如pic.baidu.com/a.txt  baidu.com/b.txt中a和b在不同的域下面，都降域为baidu.com..如下详细解释</span><br></pre></td></tr></table></figure><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源需满足的条件：</p><ul><li>协议相同</li><li>域名相同:a.b.c.com a.b.d.com域名相同吗</li><li>端口相同</li></ul><p>非同源受限制的行为：</p><ul><li>cookie localStorage indexDB无法获取</li><li>DOM无法获得</li><li>ajax请求不能发送<br>跨域方法：</li></ul><h2 id="双向跨域"><a href="#双向跨域" class="headerlink" title="双向跨域"></a>双向跨域</h2><p>1.降域(二级和以上有共同部分)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">所谓降域就是寻找到最后面的域名相同的部分留下</span><br><span class="line">a.b.c.com</span><br><span class="line">d.b.c.com</span><br><span class="line">降域后统统改为b.c.com或者c.com</span><br></pre></td></tr></table></figure><ul><li>存在的问题：<ul><li>安全性，当一个站点被攻击，相同域名的站点也会被攻击</li><li>重复性，所有需要跨域的都要修改document.domain=””</li><li>ajax不受降域影响，还是需要iframe在一个页面引入另一页面的形式</li><li>不可更改性，一旦降域就无法回去</li></ul></li></ul><p>2.location.hash(FIM—fragment itentitier messaging)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a向b传送数据</span><br><span class="line">    baidu.com/a.html中的iframe的src=&quot;google.com/b.html#paco&quot;,b.html监听到   url发生变化触发相应操作</span><br><span class="line">b向a传送数据</span><br><span class="line">    google.com/b.html中隐藏一个iframe,设置src=&quot;baidu.com/proxy.html#data&quot; data为要传输的数据,proxy.html是和a.html同域名下的，是a b之间的代理，负责监听utl变化就修改a的url，a监听到url变化了就做出相应操作</span><br></pre></td></tr></table></figure><p>b.html:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;  </span><br><span class="line">    parent.location.hash = &apos;data&apos;;  </span><br><span class="line">&#125; catch (e) &#123;  </span><br><span class="line">    // ie、chrome的安全机制无法修改parent.location.hash，  </span><br><span class="line">    var ifrproxy = document.createElement(&apos;iframe&apos;);  </span><br><span class="line">    ifrproxy.style.display = &apos;none&apos;;  </span><br><span class="line">    ifrproxy.src = &quot;http://www.baidu.com/proxy.html#data&quot;;  </span><br><span class="line">    document.body.appendChild(ifrproxy);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>proxy.html:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//因为parent.parent（即baidu.com/a.html）和baidu.com/proxy.html属于同一个域，所以可以改变其location.hash的值  </span><br><span class="line">parent.parent.location.hash = self.location.hash.substring(1);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">问题：数据暴露在URL中，数据大小格式受限</span><br></pre></td></tr></table></figure><p>3.HTML5的postMessage方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a向b发送数据</span><br></pre></td></tr></table></figure><p>baidu.com/a.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function() &#123;  </span><br><span class="line">    var ifr = document.getElementById(&apos;ifr&apos;);  </span><br><span class="line">    var targetOrigin = &quot;http://www.google.com&quot;;  </span><br><span class="line">    ifr.contentWindow.postMessage(&apos;hello world!&apos;, targetOrigin);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>google.com/b.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var onmessage = function (event) &#123;  </span><br><span class="line">  var data = event.data;//消息  </span><br><span class="line">  var origin = event.origin;//消息来源地址  </span><br><span class="line">  var source = event.source;//源Window对象  </span><br><span class="line">  if(origin==&quot;http://www.baidu.com&quot;)&#123;  </span><br><span class="line">console.log(data);//hello world!  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">if (typeof window.addEventListener != &apos;undefined&apos;) &#123;  </span><br><span class="line">  window.addEventListener(&apos;message&apos;, onmessage, false);  </span><br><span class="line">&#125; else if (typeof window.attachEvent != &apos;undefined&apos;) &#123;  </span><br><span class="line">  //for ie  </span><br><span class="line">  window.attachEvent(&apos;onmessage&apos;, onmessage);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同理可以b向a postMessage</span><br></pre></td></tr></table></figure><h2 id="单向跨域"><a href="#单向跨域" class="headerlink" title="单向跨域"></a>单向跨域</h2><p>1.jsonp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先看两种用法</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    function foo(data)&#123;</span><br><span class="line">        console.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;http://www.google.com/getUsers.js?callback=foo&quot;&gt;&lt;/script&gt;</span><br><span class="line">回调函数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://www.google.com/getUsers.php?flag=do&amp;time=1&quot;&gt;&lt;/script&gt;</span><br><span class="line">参数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">问题：只支持get请求</span><br></pre></td></tr></table></figure><p>2.服务器代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">服务器没有同源策略，在数据提供方没有jsonp,window.name协议的支持下，使用服务器代理。</span><br><span class="line">在baidu.com下配置一个代理proxy即baidu.com/proxy/将ajax绑定到代理下发送http请求，此时http请求是在服务端进行的，无同源限制</span><br></pre></td></tr></table></figure><p>3.CORS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var url = &apos;http://api.alice.com/cors&apos;;  </span><br><span class="line">var xhr = createCORSRequest(&apos;GET&apos;, url);  </span><br><span class="line">xhr.send();</span><br><span class="line">//非简单请求</span><br><span class="line">var url = &apos;http://api.alice.com/cors&apos;;  </span><br><span class="line">var xhr = createCORSRequest(&apos;PUT&apos;, url);  </span><br><span class="line">xhr.setRequestHeader(  </span><br><span class="line">    &apos;X-Custom-Header&apos;, &apos;value&apos;);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">另外：对于CORS的支持需要服务器和客户端之间的协调</span><br></pre></td></tr></table></figure><p>4.window.name</p><p>5.webSocket</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要服务器的支持，源在白名单</span><br></pre></td></tr></table></figure><p>6.Access-Controll-Allow-Origin</p><p><strong>http和https协议有什么区别，重点解释https</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http+加密+认证+完整性保护=https</span><br></pre></td></tr></table></figure><ul><li>http:应用层的无状态，超文本传输协议。端口为80</li><li>HTTPS：只是http通信接口部分用SSL和TLS协议替代。http直接和TCP通信，而HTTPS使用SSL所以是先和SSL通信，再由SSL和TCP通信。端口为443</li></ul><p><strong>cookie sessionStorage localStorage有什么不同</strong></p><ul><li>cookie存储在客户端，可以发送给服务器，数据大小限制为4K</li><li>sessionStorage,localStorage存储在本地，不可以发送给服务器，数据大小为5M</li><li>localStorage只能手动清除数据</li><li>sessionStorage关闭会话窗，数据就被清除了</li></ul><p><strong>HTML5本地存储分为</strong></p><ul><li>webStorage(localStorage,sessionStorage)</li><li>indexDB</li></ul><h2 id="DNS解析域名为IP"><a href="#DNS解析域名为IP" class="headerlink" title="DNS解析域名为IP"></a>DNS解析域名为IP</h2><ul><li>浏览器缓存中找</li><li>系统缓存中找</li><li>路由器缓存中找</li><li>ISP DNS缓存中找</li></ul><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><ul><li>client—–&gt;server:SYN(发起一个TCP连接，同步报文)</li><li>server—–&gt;client:SYN+ACK(应答报文，表示已创建连接)</li><li>client—–&gt;server:ACK(应答报文，表示收到已连接)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">四次挥手：</span><br><span class="line">    由客户端发起的关闭连接</span><br><span class="line">        * client-----&gt;server:FIN(请求关闭连接)</span><br><span class="line">        * server-----&gt;client:ACK(收到了连接，但不会立即关闭，等到报文都发送完再回复一个FIN)</span><br><span class="line">        * server-----&gt;client:FIN</span><br><span class="line">        * client-----&gt;server:ACK(收到关闭)</span><br><span class="line"></span><br><span class="line">    由服务端发起的关闭连接</span><br><span class="line">        * 当http设置了keepalive定时关闭，服务端会在结束数据传送后关闭TCP连接</span><br></pre></td></tr></table></figure><h2 id="http请求"><a href="#http请求" class="headerlink" title="http请求"></a>http请求</h2><ul><li>请求行</li><li>请求头</li><li>空行</li><li>请求包体(只有POST请求有包体)</li></ul><p><strong>get/post区别</strong></p><ul><li>请求参数：get参数附在URL后面?隔开，POST参数放在包体中</li><li>大小限制：GET限制为2048字符，post无限制</li><li>安全问题：GET参数暴露在URL中，不如POST安全</li><li>浏览器历史记录：GET可以记录，POST无记录</li><li>缓存：GET可被缓存，post无</li><li>书签：GET可被收藏为书签，post不可</li><li>数据类型：GET只能ASCII码，post无限制</li></ul><h2 id="http响应"><a href="#http响应" class="headerlink" title="http响应"></a>http响应</h2><ul><li>状态行</li><li>响应头</li><li>响应包体</li></ul><p><strong>http状态码</strong><br>1XX：表示可续发请求<br>2XX：表示成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 202成功</span><br><span class="line">* 204成功 不返回实体主体</span><br><span class="line">* 206成功 执行了一个范围请求</span><br></pre></td></tr></table></figure><p>3XX：表示重定向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 301永久重定向，增加SEO排名</span><br><span class="line">* 302临时重定向 禁止POST变为GET</span><br><span class="line">* 303另外一个URI</span><br><span class="line">* 304判断是否要更新缓存 请求头部携带if-modified-since自从上次更新距这次多久</span><br><span class="line">* 307临时重定向</span><br></pre></td></tr></table></figure><p>4XX：表示客户端错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 400客户端语法错误</span><br><span class="line">* 401请求未经授权</span><br><span class="line">* 403服务器拒绝服务</span><br><span class="line">* 404请求资源不存在</span><br></pre></td></tr></table></figure><p>5XX：服务端错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 500不可预期的错误</span><br><span class="line">* 503此时不能提供服务 稍后恢复正常</span><br></pre></td></tr></table></figure><h2 id="释放TCP连接"><a href="#释放TCP连接" class="headerlink" title="释放TCP连接"></a>释放TCP连接</h2><ul><li><p>header中的connecton:close</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">服务器主动关闭TCP连接，客户端被动关闭连接</span><br></pre></td></tr></table></figure></li><li><p>header中的connecton:keepalive</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连接保持一段时间，可以连续发送http请求</span><br></pre></td></tr></table></figure></li></ul><h2 id="客户端解析HTML"><a href="#客户端解析HTML" class="headerlink" title="客户端解析HTML"></a>客户端解析HTML</h2><p><strong>onload ready区别：</strong></p><ul><li>ready表示文档加载完毕，不包括图片</li><li>onload表示都加载完毕</li></ul><h2 id="1xx消息——代表请求已被接受，需要继续处理"><a href="#1xx消息——代表请求已被接受，需要继续处理" class="headerlink" title="1xx消息——代表请求已被接受，需要继续处理"></a>1xx消息——代表请求已被接受，需要继续处理</h2><p>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-4" target="_blank" rel="noopener">[4]</a> 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。</p><ul><li><p>100 Continue</p><p>服务器已经接收到请求头，并且客户端应继续发送请求主体（在需要发送身体的请求的情况下：例如，POST请求），或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。要使服务器检查请求的头部，客户端必须在其初始请求中发送<code>Expect: 100-continue</code>作为头部，并在发送正文之前接收<code>100 Continue</code>状态代码。响应代码417期望失败表示请求不应继续。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-iana_status_codes-2" target="_blank" rel="noopener">[2]</a></p></li></ul><ul><li><p>101 Switching Protocols</p><p>服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-5" target="_blank" rel="noopener">[5]</a></p><p>只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本（如<a href="https://zh.wikipedia.org/wiki/HTTP/2" target="_blank" rel="noopener">HTTP/2</a>）比旧版本更有优势，或者切换到一个实时且同步的协议（如<a href="https://zh.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">WebSocket</a>）以传送利用此类特性的资源。</p></li></ul><ul><li><p>102 Processing（<a href="https://zh.wikipedia.org/wiki/WebDAV" target="_blank" rel="noopener">WebDAV</a>；<a href="https://tools.ietf.org/html/rfc2518" target="_blank" rel="noopener">RFC 2518</a>）</p><p>WebDAV请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。该代码表示服务器已经收到并正在处理请求，但无响应可用。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-RFC_2518-6" target="_blank" rel="noopener">[6]</a>这样可以防止客户端超时，并假设请求丢失。</p></li></ul><h2 id="2xx成功——代表请求已成功被服务器接收、理解、并接受"><a href="#2xx成功——代表请求已成功被服务器接收、理解、并接受" class="headerlink" title="2xx成功——代表请求已成功被服务器接收、理解、并接受"></a>2xx成功——代表请求已成功被服务器接收、理解、并接受</h2><p>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-iana_status_codes-2" target="_blank" rel="noopener">[2]</a></p><ul><li><p>200 OK</p><p>请求已成功，请求所希望的响应头或数据体将随此响应返回。实际的响应将取决于所使用的请求方法。在GET请求中，响应将包含与请求的资源相对应的实体。在POST请求中，响应将包含描述或操作结果的实体。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-RFC_2616-7" target="_blank" rel="noopener">[7]</a></p></li></ul><ul><li><p>201 Created</p><p>请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其<a href="https://zh.wikipedia.org/wiki/URI" target="_blank" rel="noopener">URI</a>已经随Location头信息返回。假如需要的资源无法及时创建的话，应当返回’<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#202" target="_blank" rel="noopener">202 Accepted</a>‘。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-8" target="_blank" rel="noopener">[8]</a></p></li></ul><ul><li><p>202 Accepted</p><p>服务器已接受请求，但尚未处理。最终该请求可能会也可能不会被执行，并且可能在处理发生时被禁止。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-9" target="_blank" rel="noopener">[9]</a></p></li></ul><ul><li><p>203 Non-Authoritative Information（自HTTP / 1.1起）</p><p>服务器是一个转换代理服务器（transforming proxy，例如<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E7%B5%A1%E5%8A%A0%E9%80%9F%E5%99%A8" target="_blank" rel="noopener">网络加速器</a>），以<code>200 OK</code>状态码为起源，但回应了原始响应的修改版本。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-10" target="_blank" rel="noopener">[10]</a><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-11" target="_blank" rel="noopener">[11]</a></p></li></ul><ul><li><p>204 No Content</p><p>服务器成功处理了请求，没有返回任何内容。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-12" target="_blank" rel="noopener">[12]</a></p></li></ul><ul><li><p>205 Reset Content</p><p>服务器成功处理了请求，但没有返回任何内容。与204响应不同，此响应要求请求者重置文档视图。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-13" target="_blank" rel="noopener">[13]</a></p></li></ul><ul><li><p>206 Partial Content（<a href="https://tools.ietf.org/html/rfc7233" target="_blank" rel="noopener">RFC 7233</a>）</p><p>服务器已经成功处理了部分GET请求。类似于<a href="https://zh.wikipedia.org/wiki/FlashGet" target="_blank" rel="noopener">FlashGet</a>或者<a href="https://zh.wikipedia.org/wiki/%E8%BF%85%E9%9B%B7" target="_blank" rel="noopener">迅雷</a>这类的HTTP <a href="https://zh.wikipedia.org/wiki/Category:%E4%B8%8B%E8%BC%89%E5%B7%A5%E5%85%B7" target="_blank" rel="noopener">下载工具</a>都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-14" target="_blank" rel="noopener">[14]</a></p></li></ul><ul><li><p>207 Multi-Status（WebDAV；<a href="https://tools.ietf.org/html/rfc4918" target="_blank" rel="noopener">RFC 4918</a>）</p><p>代表之后的消息体将是一个<a href="https://zh.wikipedia.org/wiki/XML" target="_blank" rel="noopener">XML</a>消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-RFC_4918-15" target="_blank" rel="noopener">[15]</a></p></li></ul><ul><li><p>208 Already Reported （WebDAV；<a href="https://tools.ietf.org/html/rfc5842" target="_blank" rel="noopener">RFC 5842</a>）</p><p>DAV绑定的成员已经在（多状态）响应之前的部分被列举，且未被再次包含。</p></li></ul><ul><li><p>226 IM Used （<a href="https://tools.ietf.org/html/rfc3229" target="_blank" rel="noopener">RFC 3229</a>）</p><p>服务器已经满足了对资源的请求，对实体请求的一个或多个实体操作的结果表示。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-RFC_3229-16" target="_blank" rel="noopener">[16]</a></p></li></ul><h2 id="3xx重定向——代表需要客户端采取进一步的操作才能完成请求"><a href="#3xx重定向——代表需要客户端采取进一步的操作才能完成请求" class="headerlink" title="3xx重定向——代表需要客户端采取进一步的操作才能完成请求"></a>3xx重定向——代表需要客户端采取进一步的操作才能完成请求</h2><p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-iana_status_codes-2" target="_blank" rel="noopener">[2]</a></p><p>当且仅当后续的请求所使用的方法是GET或者HEAD时，用户<a href="https://zh.wikipedia.org/wiki/%E6%B5%8F%E8%A7%88%E5%99%A8" target="_blank" rel="noopener">浏览器</a>才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测<a href="https://zh.wikipedia.org/wiki/%E6%AD%BB%E5%BE%AA%E7%92%B0" target="_blank" rel="noopener">无限循环</a>重定向（例如：A→B→C→……→A或A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照HTTP/1.0版规范的建议，浏览器不应自动访问超过5次的重定向。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-17" target="_blank" rel="noopener">[17]</a></p><ul><li><p>300 Multiple Choices</p><p>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-18" target="_blank" rel="noopener">[18]</a></p><p>除非这是一个HEAD请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由Content-Type定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。</p><p>如果服务器本身已经有了首选的回馈选择，那么在Location中应当指明这个回馈的<a href="https://zh.wikipedia.org/wiki/URI" target="_blank" rel="noopener">URI</a>；浏览器可能会将这个Location值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</p></li></ul><ul><li><p><a href="https://zh.wikipedia.org/wiki/HTTP_301" target="_blank" rel="noopener">301 Moved Permanently</a></p><p>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-19" target="_blank" rel="noopener">[19]</a>除非额外指定，否则这个响应也是可缓存的。</p><p>新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E9%93%BE%E6%8E%A5" target="_blank" rel="noopener">超链接</a>及简短说明。</p><p>如果这不是一个GET或者HEAD请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</p><p>注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。</p></li></ul><ul><li><p><a href="https://zh.wikipedia.org/wiki/HTTP_302" target="_blank" rel="noopener">302 Found</a></p><p>要求客户端执行临时重定向（原始描述短语为“Moved Temporarily”）。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-RFC_1945-20" target="_blank" rel="noopener">[20]</a>由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</p><p>新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。</p><p>如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</p><p>注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#303" target="_blank" rel="noopener">303响应</a>，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-ruby-on-rails-ActionController-Redirecting-redirect_to-21" target="_blank" rel="noopener">[21]</a>因此状态码303和<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#307" target="_blank" rel="noopener">307</a>被添加了进来，用以明确服务器期待客户端进行何种反应。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-RFC7230-10-22" target="_blank" rel="noopener">[22]</a></p></li></ul><ul><li><p><a href="https://zh.wikipedia.org/wiki/HTTP_303" target="_blank" rel="noopener">303 See Other</a></p><p>对应当前请求的响应可以在另一个URI上被找到，当响应于POST（或PUT / DELETE）接收到响应时，客户端应该假定服务器已经收到数据，并且应该使用单独的GET消息发出重定向。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-23" target="_blank" rel="noopener">[23]</a>这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的URI不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。</p><p>新的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。</p><p>注意：许多HTTP/1.1版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#302" target="_blank" rel="noopener">302状态码</a>应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</p></li></ul><ul><li><p>304 Not Modified</p><p>表示资源未被修改，因为请求头指定的版本If-Modified-Since或If-None-Match。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-24" target="_blank" rel="noopener">[24]</a></p></li></ul><ul><li><p>305 Use Proxy</p><p>被请求的资源必须通过指定的代理才能被访问。Location域中将给出指定的代理所在的URI信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能创建305响应。许多HTTP客户端（像是<a href="https://zh.wikipedia.org/wiki/Mozilla" target="_blank" rel="noopener">Mozilla</a><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-mozilla_bugzilla_bug_187996-25" target="_blank" rel="noopener">[25]</a>和<a href="https://zh.wikipedia.org/wiki/Internet_Explorer" target="_blank" rel="noopener">Internet Explorer</a>）都没有正确处理这种状态代码的响应，主要是出于安全考虑。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-mozilla_bugzilla_bug_187996_comment_13-26" target="_blank" rel="noopener">[26]</a></p><p>注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</p></li></ul><ul><li><p>306 Switch Proxy</p><p>在最新版的规范中，306状态码已经不再被使用。最初是指“后续请求应使用指定的代理”。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-27" target="_blank" rel="noopener">[27]</a></p></li></ul><ul><li><p><a href="https://zh.wikipedia.org/wiki/HTTP_307" target="_blank" rel="noopener">307 Temporary Redirect</a></p><p>在这种情况下，请求应该与另一个URI重复，但后续的请求应仍使用原始的URI。 与302相反，当重新发出原始请求时，不允许更改请求方法。 例如，应该使用另一个POST请求来重复POST请求。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-SemanticsAndContent-28" target="_blank" rel="noopener">[28]</a></p></li></ul><ul><li><p>308 Permanent Redirect (<a href="https://tools.ietf.org/html/rfc7538" target="_blank" rel="noopener">RFC 7538</a>)</p><p>请求和所有将来的请求应该使用另一个URI重复。 307和308重复302和301的行为，但不允许HTTP方法更改。 例如，将表单提交给永久重定向的资源可能会顺利进行。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-rfc7238-29" target="_blank" rel="noopener">[29]</a></p></li></ul><h2 id="4xx客户端错误——代表了客户端看起来可能发生了错误，妨碍了服务器的处理"><a href="#4xx客户端错误——代表了客户端看起来可能发生了错误，妨碍了服务器的处理" class="headerlink" title="4xx客户端错误——代表了客户端看起来可能发生了错误，妨碍了服务器的处理"></a>4xx客户端错误——代表了客户端看起来可能发生了错误，妨碍了服务器的处理</h2><p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-30" target="_blank" rel="noopener">[30]</a></p><p>如果错误发生时客户端正在传送数据，那么使用<a href="https://zh.wikipedia.org/wiki/TCP" target="_blank" rel="noopener">TCP</a>的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%8C%85" target="_blank" rel="noopener">数据包</a>。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入<a href="https://zh.wikipedia.org/w/index.php?title=%E7%BC%93%E5%86%B2&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">缓冲</a>，以免这些数据被服务器上的<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F" target="_blank" rel="noopener">应用程序</a>读取并干扰后者。</p><ul><li><p>400 Bad Request</p><p>由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-rfc7231-400-31" target="_blank" rel="noopener">[31]</a></p></li></ul><ul><li><p>401 Unauthorized（<a href="https://tools.ietf.org/html/rfc7235" target="_blank" rel="noopener">RFC 7235</a>）</p><p>参见：<a href="https://zh.wikipedia.org/wiki/HTTP%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81" target="_blank" rel="noopener">HTTP基本认证</a>、<a href="https://zh.wikipedia.org/wiki/HTTP%E6%91%98%E8%A6%81%E8%AE%A4%E8%AF%81" target="_blank" rel="noopener">HTTP摘要认证</a></p><p>类似于403 Forbidden，401语义即“<a href="https://zh.wikipedia.org/wiki/%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81" target="_blank" rel="noopener">未认证</a>”，即用户没有必要的凭据。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-rfc7235-401-32" target="_blank" rel="noopener">[32]</a>该状态码表示当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-33" target="_blank" rel="noopener">[33]</a>如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。</p><p>注意：当网站（通常是网站域名）禁止IP地址时，有些网站状态码显示的401，表示该特定地址被拒绝访问网站。</p></li></ul><ul><li><p>402 Payment Required</p><p>该状态码是为了将来可能的需求而预留的。该状态码最初的意图可能被用作某种形式的数字现金或在线支付方案的一部分，但几乎没有哪家服务商使用，而且这个状态码通常不被使用。如果特定开发人员已超过请求的每日限制，<a href="https://zh.wikipedia.org/wiki/Google_Developers" target="_blank" rel="noopener">Google Developers</a> API会使用此状态码。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-GoogleDevelopersErrorCode-34" target="_blank" rel="noopener">[34]</a></p></li></ul><ul><li>403 Forbidden</li></ul><p>主条目：<a href="https://zh.wikipedia.org/wiki/HTTP_403" target="_blank" rel="noopener">HTTP 403</a></p><ul><li>404 Not Found</li></ul><p>主条目：<a href="https://zh.wikipedia.org/wiki/HTTP_404" target="_blank" rel="noopener">HTTP 404</a></p><ul><li><p>405 Method Not Allowed</p><p>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表。例如，需要通过POST呈现数据的表单上的GET请求，或只读资源上的PUT请求。</p><p>鉴于PUT，DELETE方法会对服务器上的资源进行写操作，因而绝大部分的<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%A1%B5%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">网页服务器</a>都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</p></li></ul><ul><li><p>406 Not Acceptable</p><p>参见：<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86" target="_blank" rel="noopener">内容协商</a></p><p>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体，该请求不可接受。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-36" target="_blank" rel="noopener">[36]</a></p><p>除非这是一个HEAD请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由Content-Type头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</p></li></ul><ul><li><p>407 Proxy Authentication Required（<a href="https://tools.ietf.org/html/rfc2617" target="_blank" rel="noopener">RFC 2617</a>）</p><p>与<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#401" target="_blank" rel="noopener">401响应</a>类似，只不过客户端必须在代理服务器上进行身份验证。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-37" target="_blank" rel="noopener">[37]</a>代理服务器必须返回一个Proxy-Authenticate用以进行身份询问。客户端可以返回一个Proxy-Authorization信息头用以验证。</p></li></ul><ul><li><p>408 Request Timeout</p><p>请求超时。根据HTTP规范，客户端没有在服务器预备等待的时间内完成一个请求的发送，客户端可以随时再次提交这一请求而无需进行任何更改。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-38" target="_blank" rel="noopener">[38]</a></p></li></ul><ul><li><p>409 Conflict</p><p>表示因为请求存在冲突无法处理该请求，例如多个同步更新之间的<a href="https://zh.wikipedia.org/w/index.php?title=%E7%BC%96%E8%BE%91%E5%86%B2%E7%AA%81&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">编辑冲突</a>。</p></li></ul><ul><li><p>410 Gone</p><p>表示所请求的资源不再可用，将不再可用。当资源被有意地删除并且资源应被清除时，应该使用这个。在收到410状态码后，用户应停止再次请求资源。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-HTTP_410-39" target="_blank" rel="noopener">[39]</a>但大多数服务端不会使用此状态码，而是直接使用<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#404" target="_blank" rel="noopener">404状态码</a>。</p></li></ul><ul><li><p>411 Length Required</p><p>服务器拒绝在没有定义Content-Length头的情况下接受请求。在添加了表明请求消息体长度的有效Content-Length头之后，客户端可以再次提交该请求。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-40" target="_blank" rel="noopener">[40]</a></p></li></ul><ul><li><p>412 Precondition Failed（<a href="https://tools.ietf.org/html/rfc7232" target="_blank" rel="noopener">RFC 7232</a>）</p><p>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-41" target="_blank" rel="noopener">[41]</a>这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</p></li></ul><ul><li><p>413 Request Entity Too Large（<a href="https://tools.ietf.org/html/rfc7231" target="_blank" rel="noopener">RFC 7231</a>）</p><p>前称“Request Entity Too Large”，表示服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-42" target="_blank" rel="noopener">[42]</a>此种情况下，服务器可以关闭连接以免客户端继续发送此请求。</p><p>如果这个状况是临时的，服务器应当返回一个Retry-After的响应头，以告知客户端可以在多少时间以后重新尝试。</p></li></ul><ul><li><p>414 Request-URI Too Long（<a href="https://tools.ietf.org/html/rfc7231" target="_blank" rel="noopener">RFC 7231</a>）</p><p>前称“Request-URI Too Long”，<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-43" target="_blank" rel="noopener">[43]</a>表示请求的URI长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。通常将太多数据的结果编码为GET请求的查询字符串，在这种情况下，应将其转换为POST请求。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-44" target="_blank" rel="noopener">[44]</a>这比较少见，通常的情况包括：本应使用POST方法的表单提交变成了GET方法，导致<a href="https://zh.wikipedia.org/w/index.php?title=%E6%9F%A5%E8%AF%A2%E5%AD%97%E7%AC%A6%E4%B8%B2&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">查询字符串</a>过长。重定向URI“黑洞”，例如每次重定向把旧的URI作为新的URI的一部分，导致在若干次重定向后URI超长。客户端正在尝试利用某些服务器中存在的<a href="https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E" target="_blank" rel="noopener">安全漏洞</a>攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的URI，当GET后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-45" target="_blank" rel="noopener">[45]</a>。没有此类漏洞的服务器，应当返回414状态码。</p></li></ul><ul><li><p>415 Unsupported Media Type</p><p>对于当前请求的方法和所请求的资源，请求中提交的<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">互联网媒体类型</a>并不是服务器中所支持的格式，因此请求被拒绝。例如，客户端将图像上传格式为svg，但服务器要求图像使用上传格式为jpg。</p></li></ul><ul><li><p>416 Requested Range Not Satisfiable（<a href="https://tools.ietf.org/html/rfc7233" target="_blank" rel="noopener">RFC 7233</a>）</p><p>前称“Requested Range Not Satisfiable”。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-46" target="_blank" rel="noopener">[46]</a>客户端已经要求文件的一部分（<a href="https://zh.wikipedia.org/w/index.php?title=Byte_serving&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">Byte serving</a>），但服务器不能提供该部分。例如，如果客户端要求文件的一部分超出文件尾端。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-47" target="_blank" rel="noopener">[47]</a></p></li></ul><ul><li><p>417 Expectation Failed</p><p>在请求头Expect中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服显的证据证明在当前<a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1" target="_blank" rel="noopener">路由</a>的下一个节点上，Expect的内容无法被满足。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-48" target="_blank" rel="noopener">[48]</a></p></li></ul><ul><li><p>418 I’m a teapot（<a href="https://tools.ietf.org/html/rfc2324" target="_blank" rel="noopener">RFC 2324</a>）</p><p>本操作码是在1998年作为<a href="https://zh.wikipedia.org/wiki/IETF" target="_blank" rel="noopener">IETF</a>的传统<a href="https://zh.wikipedia.org/wiki/%E6%83%A1%E6%90%9ERFC" target="_blank" rel="noopener">愚人节笑话</a>, 在RFC 2324<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E5%92%96%E5%95%A1%E5%A3%B6%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">超文本咖啡壶控制协议</a>‘中定义的，并不需要在真实的HTTP服务器中定义。当一个控制茶壶的<a href="https://zh.wikipedia.org/wiki/HTCPCP" target="_blank" rel="noopener">HTCPCP</a>收到BREW或POST指令要求其煮咖啡时应当回传此错误。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-49" target="_blank" rel="noopener">[49]</a>这个HTTP状态码在某些网站（包括Google.com）与项目（如<a href="https://zh.wikipedia.org/wiki/Node.js" target="_blank" rel="noopener">Node.js</a>、<a href="https://zh.wikipedia.org/wiki/ASP.NET" target="_blank" rel="noopener">ASP.NET</a>和<a href="https://zh.wikipedia.org/wiki/Go%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">Go语言</a>）中用作<a href="https://zh.wikipedia.org/wiki/%E5%BD%A9%E8%9B%8B_(%E5%AA%92%E4%BD%93" target="_blank" rel="noopener">彩蛋</a>)。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-50" target="_blank" rel="noopener">[50]</a></p></li></ul><ul><li><p>420 Enhance Your Caim</p><p>Twitter Search与Trends API在客户端被限速的情况下返回。</p></li></ul><ul><li><p>421 Misdirected Request （<a href="https://tools.ietf.org/html/rfc7540" target="_blank" rel="noopener">RFC 7540</a>）</p><p>该请求针对的是无法产生响应的服务器（例如因为连接重用）。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-HTTP2-51" target="_blank" rel="noopener">[51]</a></p></li></ul><ul><li><p>422 Unprocessable Entity（<a href="https://zh.wikipedia.org/wiki/WebDAV" target="_blank" rel="noopener">WebDAV</a>；<a href="https://tools.ietf.org/html/rfc4918" target="_blank" rel="noopener">RFC 4918</a> ）</p><p>请求格式正确，但是由于含有<a href="https://zh.wikipedia.org/wiki/%E8%AF%AD%E4%B9%89" target="_blank" rel="noopener">语义</a>错误，无法响应。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-RFC_4918-15" target="_blank" rel="noopener">[15]</a></p></li></ul><ul><li><p>423 Locked（<a href="https://zh.wikipedia.org/wiki/WebDAV" target="_blank" rel="noopener">WebDAV</a>；<a href="https://tools.ietf.org/html/rfc4918" target="_blank" rel="noopener">RFC 4918</a>）</p><p>当前资源被锁定。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-RFC_4918-15" target="_blank" rel="noopener">[15]</a></p></li></ul><ul><li><p>424 Failed Dependency（<a href="https://zh.wikipedia.org/wiki/WebDAV" target="_blank" rel="noopener">WebDAV</a>；<a href="https://tools.ietf.org/html/rfc4918" target="_blank" rel="noopener">RFC 4918</a>）</p><p>由于之前的某个请求发生的错误，导致当前请求失败，例如PROPPATCH。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-RFC_4918-15" target="_blank" rel="noopener">[15]</a></p></li></ul><ul><li><p>425 Unordered Collection</p><p>在WebDAV Advanced Collections Protocol中定义，但Web Distributed Authoring and Versioning (WebDAV) Ordered Collections Protocol中并不存在。</p></li></ul><ul><li><p>426 Upgrade Required（<a href="https://tools.ietf.org/html/rfc2817" target="_blank" rel="noopener">RFC 2817</a>）</p><p>客户端应当切换到<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AE%89%E5%85%A8" target="_blank" rel="noopener">TLS/1.0</a>，并在<a href="https://zh.wikipedia.org/w/index.php?title=HTTP/1.1_Upgrade_header&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">HTTP/1.1 Upgrade header</a>中给出。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-RFC_4918-15" target="_blank" rel="noopener">[15]</a></p></li></ul><ul><li><p>428 Precondition Required (<a href="https://tools.ietf.org/html/rfc6585" target="_blank" rel="noopener">RFC 6585</a>)</p><p>原服务器要求该请求满足一定条件。这是为了防止“‘未更新’问题，即客户端读取（GET）一个资源的状态，更改它，并将它写（PUT）回服务器，但这期间第三方已经在服务器上更改了该资源的状态，因此导致了冲突。”<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-rfc6585-52" target="_blank" rel="noopener">[52]</a></p></li></ul><ul><li><p>429 Too Many Requests （<a href="https://tools.ietf.org/html/rfc6585" target="_blank" rel="noopener">RFC 6585</a>）</p><p>用户在给定的时间内发送了太多的请求。旨在用于<a href="https://zh.wikipedia.org/w/index.php?title=%E7%BD%91%E7%BB%9C%E9%99%90%E9%80%9F&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">网络限速</a>。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-rfc6585-52" target="_blank" rel="noopener">[52]</a></p></li></ul><ul><li><p>431 Request Header Fields Too Large （<a href="https://tools.ietf.org/html/rfc6585" target="_blank" rel="noopener">RFC 6585</a>）</p><p>服务器不愿处理请求，因为一个或多个头字段过大。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-rfc6585-52" target="_blank" rel="noopener">[52]</a></p></li></ul><ul><li><p>444 No Response</p><p>Nginx上HTTP服务器扩展。服务器不向客户端返回任何信息，并关闭连接（有助于阻止恶意软件）。</p></li></ul><ul><li><p>450 Blocked by Windows Parental Controls</p><p>这是一个由Windows家庭控制（Microsoft）HTTP阻止的450状态代码的示例，用于信息和测试。</p></li></ul><ul><li><p><a href="https://zh.wikipedia.org/wiki/HTTP_451" target="_blank" rel="noopener">451 Unavailable For Legal Reasons</a></p><p>该访问因<a href="https://zh.wikipedia.org/wiki/%E6%B3%95%E5%BE%8B" target="_blank" rel="noopener">法律</a>的要求而被拒绝，由<a href="https://zh.wikipedia.org/wiki/IETF" target="_blank" rel="noopener">IETF</a>在2015核准后新增加。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-53" target="_blank" rel="noopener">[53]</a><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-54" target="_blank" rel="noopener">[54]</a><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-55" target="_blank" rel="noopener">[55]</a></p></li></ul><ul><li><p>494 Request Header Too Large</p><p>在错误代码431提出之前Nginx上使用的扩展HTTP代码。</p></li></ul><h2 id="5xx服务器错误——表示服务器无法完成明显有效的请求"><a href="#5xx服务器错误——表示服务器无法完成明显有效的请求" class="headerlink" title="5xx服务器错误——表示服务器无法完成明显有效的请求"></a>5xx服务器错误——表示服务器无法完成明显有效的请求</h2><p>表示服务器无法完成明显有效的请求。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-56" target="_blank" rel="noopener">[56]</a>这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-57" target="_blank" rel="noopener">[57]</a></p><ul><li><p>500 Internal Server Error</p><p>通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。没有给出具体错误信息。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-58" target="_blank" rel="noopener">[58]</a></p></li></ul><ul><li><p>501 Not Implemented</p><p>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-59" target="_blank" rel="noopener">[59]</a>（例如，网络服务API的新功能）</p></li></ul><ul><li><p>502 Bad Gateway</p><p>作为<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E5%85%B3" target="_blank" rel="noopener">网关</a>或者<a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">代理</a>工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-60" target="_blank" rel="noopener">[60]</a></p></li></ul><ul><li><p>503 Service Unavailable</p><p>由于临时的服务器维护或者<a href="https://zh.wikipedia.org/w/index.php?title=%E8%BF%87%E8%BD%BD&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">过载</a>，服务器当前无法处理请求。这个状况是暂时的，并且将在一段时间以后恢复。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-61" target="_blank" rel="noopener">[61]</a>如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理<a href="https://zh.wikipedia.org/w/index.php?title=500_Internal_Error&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">500响应</a>的方式处理它。</p></li></ul><ul><li><p>504 Gateway Timeout</p><p>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如<a href="https://zh.wikipedia.org/wiki/HTTP" target="_blank" rel="noopener">HTTP</a>、<a href="https://zh.wikipedia.org/wiki/FTP" target="_blank" rel="noopener">FTP</a>、<a href="https://zh.wikipedia.org/wiki/LDAP" target="_blank" rel="noopener">LDAP</a>）或者辅助服务器（例如<a href="https://zh.wikipedia.org/wiki/DNS" target="_blank" rel="noopener">DNS</a>）收到响应。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-62" target="_blank" rel="noopener">[62]</a></p><p>注意：某些代理服务器在DNS查询<a href="https://zh.wikipedia.org/w/index.php?title=%E8%B6%85%E6%97%B6&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">超时</a>时会返回<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#400" target="_blank" rel="noopener">400</a>或者<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#500" target="_blank" rel="noopener">500</a>错误。</p></li></ul><ul><li><p>505 HTTP Version Not Supported</p><p>服务器不支持，或者拒绝支持在请求中使用的HTTP版本。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-63" target="_blank" rel="noopener">[63]</a>这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</p></li></ul><ul><li><p>506 Variant Also Negotiates（<a href="https://tools.ietf.org/html/rfc2295" target="_blank" rel="noopener">RFC 2295</a>）</p><p>由《透明内容协商协议》（<a href="https://tools.ietf.org/html/rfc2295" target="_blank" rel="noopener">RFC 2295</a>）扩展，代表服务器存在内部配置错误，<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-RFC_2295-64" target="_blank" rel="noopener">[64]</a>被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</p></li></ul><ul><li><p>507 Insufficient Storage（<a href="https://zh.wikipedia.org/wiki/WebDAV" target="_blank" rel="noopener">WebDAV</a>；<a href="https://tools.ietf.org/html/rfc4918" target="_blank" rel="noopener">RFC 4918</a>）</p><p>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-RFC_4918-15" target="_blank" rel="noopener">[15]</a></p></li></ul><ul><li><p>508 Loop Detected （<a href="https://zh.wikipedia.org/wiki/WebDAV" target="_blank" rel="noopener">WebDAV</a>；<a href="https://tools.ietf.org/html/rfc5842" target="_blank" rel="noopener">RFC 5842</a>）</p><p>服务器在处理请求时陷入死循环。 （可代替 <a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#208" target="_blank" rel="noopener">208状态码</a>）</p></li></ul><ul><li><p>510 Not Extended（<a href="https://tools.ietf.org/html/rfc2774" target="_blank" rel="noopener">RFC 2774</a>）</p><p>获取资源所需要的策略并没有被满足。<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-RFC_2774-65" target="_blank" rel="noopener">[65]</a></p></li></ul><ul><li><p>511 Network Authentication Required （<a href="https://tools.ietf.org/html/rfc6585" target="_blank" rel="noopener">RFC 6585</a>）</p><p>客户端需要进行身份验证才能获得网络访问权限，旨在限制用户群访问特定网络。（例如连接<a href="https://zh.wikipedia.org/wiki/%E7%83%AD%E7%82%B9_(Wi-Fi" target="_blank" rel="noopener">WiFi热点</a>)时的<a href="https://zh.wikipedia.org/w/index.php?title=%E5%BC%BA%E5%88%B6%E7%BD%91%E7%BB%9C%E9%97%A8%E6%88%B7&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">强制网络门户</a>）<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#cite_note-rfc6585-52" target="_blank" rel="noopener">[52]</a></p></li></ul><h1 id="输入URL后发生了什么"><a href="#输入URL后发生了什么" class="headerlink" title="输入URL后发生了什么"></a>输入URL后发生了什么</h1><ol><li>用户在浏览器地址栏中输入网站域名</li><li>浏览器拿到该域名先去本地hosts文件中查找对应的ip地址，未找到时自动去请求 DNS服务器查询 用户输入的域名对应的 ip 地址</li><li>浏览器拿到 ip 地址之后，通过ip地址+端口号（HTTP默认80）和服务器建立连接（通过 三次握手 ）</li><li>三次握手建立连接成功之后浏览器将用户输入的 url 地址通过 HTTP 协议包装成 请求报文 ，然后通过 Socket（服务器ip地址和端口号） 发送到服务器</li><li>当HTTP服务器接收到客户端浏览器发送过来的请求报文时候，按照 HTTP 协议将请求报文解析出来</li><li>然后服务器拿到请求报文中的请求信息（例如请求路径url），做相应的业务逻辑处理操作</li><li>当业务逻辑处理完毕之后，服务器将要发送给客户端的数据按照 HTTP 协议包装成 响应报文</li><li>然后服务器通过 Socket（客户端的ip地址+端口号） 将响应报文数据发送给客户端浏览器</li><li>当浏览器接收到服务器发送给自己的响应报文数据的时候，浏览器根据 HTTP 协议将报文内容解析出来</li><li>浏览器拿到响应报文体中的数据开始 解析渲染html、css，执行 JavaScript，如果在解析的过程（从上到下）中，发现有外链的标签（link、css、img），浏览器会自动对该标签指向的 路径地址 发起新的请求（还是通过 Socket ）。</li><li>解析html生成dom树 + cssom树，结合二者生成最终的渲染树，然后浏览器UI后端进行最终的绘制。浏览器解析渲染的过程并非严格顺序执行的，而是串行进行，为了提高网页性能，要减少浏览器的reflow和repaint。</li></ol><p><img src="/var/folders/9z/8xx9sv750sx31xn88v4x0bh80000gn/T/abnerworks.Typora/image-201803192144509.png" alt="mage-20180319214450"></p><p><img src="/var/folders/9z/8xx9sv750sx31xn88v4x0bh80000gn/T/abnerworks.Typora/image-201803192146024.png" alt="mage-20180319214602"></p>]]></content>
    
    <summary type="html">
    
      HTTP&amp;&amp;URL输入后的反应
    
    </summary>
    
      <category term="HTTP" scheme="http://yoursite.com/categories/HTTP/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="面经" scheme="http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的JavaScript</title>
    <link href="http://yoursite.com/2018/03/28/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    <id>http://yoursite.com/2018/03/28/你不知道的JavaScript/</id>
    <published>2018-03-27T16:00:00.000Z</published>
    <updated>2018-04-09T13:16:36.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1 作用域"></a>1 作用域</h1><h2 id="1-1-RHS、LHS"><a href="#1-1-RHS、LHS" class="headerlink" title="1.1 RHS、LHS"></a>1.1 RHS、LHS</h2><p>​    <strong>LHS</strong> : <strong>赋值操作的目标是谁</strong>对哪个赋值就对哪个进行<strong>LHS</strong>引用，可以理解为赋值操作的目标。<strong>var c 等号左边</strong></p><p>​    <strong>RHS</strong> : <strong>谁是赋值操作的源头（retrieve his source value）</strong>,需要获取哪个变量的值，就对哪个变量的值进行<strong>RHS</strong>引用，理解为赋值操作的源头。<strong>c = 2 等号右边</strong></p><p>​    <strong>异常 :</strong> 当<strong>RHS</strong>在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出<strong>ReferenceError</strong>异常<br>                  当<strong>LHS</strong>在所有嵌套的作用域中遍寻不到所需的变量，全局作用域会创建一个具有改名称的变量，并将其返还给引擎(<strong>非严格模式</strong>下)，在<strong>严格模式</strong>下并不创建且抛出<strong>ReferenceError</strong></p><blockquote><p>​    这两种不同的引用方式的在对没有声明的变量的处理上是不同的。而这个不同之处对于我们编写代码和分析JS引擎报的错误是很有用处的。</p><ul><li>当对一个变量执行RHS查询时，如果遍历该变量所在处的词法作用域未能找到这个变量，JS引擎就会抛出 ReferenceError 错误如果成功查询到了这个变量，但是对这个变量执行不合理操作，比如对一个非数组的变量执行下标取值，JS引擎就会抛出 TypeError 错误。</li><li>当对一个变量执行LHS查询时，同样在遍历作用域后无法找到该变量，在非ES5的严格模式下，系统就会自动在全局作用域中创建一个同名变量，并将引用转移到该新建的全局变量中。而在ES5的严格模式下，LHS查询失败时JS引擎会抛出一个同RHS一样的 ReferenceError 错误。</li></ul><p>因此，对LHS查询和RHS查询的仔细区分和理解无论是对JS执行过程本身的理解还是分析错误都是有所好处的。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//RHS foo(2)-&gt;foo</span></span><br><span class="line"><span class="comment">//LHS 2-&gt;a a = 2</span></span><br><span class="line"><span class="comment">//RHS console</span></span><br><span class="line"><span class="comment">//RHS .log()</span></span><br><span class="line"><span class="comment">//RHS a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123; <span class="comment">//a = 2</span></span><br><span class="line">    <span class="keyword">var</span> a = b;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = foo(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//LHS c=... ; a = 2 ; b = ....</span></span><br><span class="line"><span class="comment">//RHS foo(2... ; = a; ; a.. ; ..b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一，var c中的c需要被赋值，在赋值操作的左侧，所以对c进行LHS引用</span></span><br><span class="line"><span class="comment">//第二，变量c需要被赋值，他的值是foo(2),那么foo(2)的值是多少呢，需要查找foo(2)的值，在赋值操作的右侧，所以对foo(2)进行RHS引用</span></span><br><span class="line"><span class="comment">//第三，隐含赋值操作，将2传递给function foo(a)&#123;……&#125;函数的参数a，a在赋值操作的左侧，对a进行LHS引用</span></span><br><span class="line"><span class="comment">//第四，var b=a;中，b需要被赋值，处在赋值操作的左侧，所以b进行的LHS，b的值将从a来，那么右侧的a的值从何而来呢？这就需要对赋值操作右侧的a进行RHS。</span></span><br><span class="line"><span class="comment">//第五，return a+b;中，需要找到a与b的值的来源，a与b都在赋值操作的右侧，才能得到a+b的值，所以对a与b都是进行RHS引用。</span></span><br></pre></td></tr></table></figure><h2 id="1-2-词法作用域"><a href="#1-2-词法作用域" class="headerlink" title="1.2 词法作用域"></a>1.2 词法作用域</h2><p>​    <strong>词法作用域</strong>就是定义在词法阶段的作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   1.  包含着整个全局作用域，其中只有一个标识符: foo。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//   2.   包含着foo 所创建的作用域，其中有三个标识符: a、bar 和b。</span></span><br><span class="line">    <span class="keyword">var</span> b = a * <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//   3.   包含着bar 所创建的作用域，其中只有一个标识符: C。</span></span><br><span class="line">        <span class="built_in">console</span>.log(a,b,c);</span><br><span class="line">        <span class="comment">// 3 END</span></span><br><span class="line">    &#125;</span><br><span class="line">    bar(b * <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 2 END</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>); <span class="comment">// 2,4,12;</span></span><br><span class="line"><span class="comment">// 1 END</span></span><br></pre></td></tr></table></figure><h3 id="1-2-1-eval"><a href="#1-2-1-eval" class="headerlink" title="1.2.1 eval()"></a>1.2.1 eval()</h3><p>前提为非严格模式下！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str, a</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>( str ); <span class="comment">//欺诈</span></span><br><span class="line">    <span class="built_in">console</span>.log(a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">foo(<span class="string">"var b = 3"</span>, <span class="number">1</span>); <span class="comment">//1, 3</span></span><br></pre></td></tr></table></figure><h3 id="1-2-2-with"><a href="#1-2-2-with" class="headerlink" title="1.2.2 with()"></a>1.2.2 with()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">with</span>(obj)&#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">    a : <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123;</span><br><span class="line">    b : <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo(o1);</span><br><span class="line"><span class="built_in">console</span>.log( o1.a); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">foo(o2);</span><br><span class="line"><span class="built_in">console</span>.log( o2.a); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log( a );  <span class="comment">//2  -&gt; a被泄漏到全局作用域</span></span><br></pre></td></tr></table></figure><p>​    在with块内部，看起来只是对变量a进行简单的词法引用，实际上是一个LHS引用，并将2赋值给它</p><h2 id="1-3-函数作用域和块作用域"><a href="#1-3-函数作用域和块作用域" class="headerlink" title="1.3 函数作用域和块作用域"></a>1.3 函数作用域和块作用域</h2><h3 id="1-3-1-规避冲突"><a href="#1-3-1-规避冲突" class="headerlink" title="1.3.1 规避冲突"></a>1.3.1 规避冲突</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">        i = <span class="number">3</span>;   <span class="comment">//修改for循环所属作用域中的i</span></span><br><span class="line">        <span class="built_in">console</span>.log(a + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        bar( i * <span class="number">2</span>);    <span class="comment">//无限循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决：</p><ul><li>全局命名空间</li><li>模块管理</li></ul><h3 id="1-3-2-函数作用域"><a href="#1-3-2-函数作用域" class="headerlink" title="1.3.2 函数作用域"></a>1.3.2 函数作用域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( a );   <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>此方法需声明函数foo，但foo名称污染了所在作用域，且必须显式的通过foo函数名才能调用foo函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">23</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);  <span class="comment">//23</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>此方法函数会被当作函数表达式而不是一个标准的函数声明来处理</p><blockquote><p>区分函数声明和表达式最简单的方法是看function关键词出现在声明中的位置（整个声明中的位置），如果function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式</p></blockquote><p>(function(){….})作为函数表达式意味着foo只能在…所代表的位置中被访问，外部作用域则不行。</p><h3 id="1-3-3-匿名函数"><a href="#1-3-3-匿名函数" class="headerlink" title="1.3.3 匿名函数"></a>1.3.3 匿名函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hhh"</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>函数表达式可以是匿名的，但函数声明不可以省略函数名</p><p><strong>匿名函数缺点</strong></p><ol><li>匿名函数在栈追踪中不会显示出有意义的函数名，<strong>使得调试很困难</strong></li><li><strong>降低代码可读性</strong></li><li>当函数需要引用自身时只能使用已经过期的arguments.callee引用，比如：在递归中、事件触发后事件监听器需要解绑自身</li></ol><h3 id="1-3-4-IIFE-立即执行函数表达式"><a href="#1-3-4-IIFE-立即执行函数表达式" class="headerlink" title="1.3.4 IIFE 立即执行函数表达式"></a>1.3.4 IIFE 立即执行函数表达式</h3><p><strong>IIFE （Immediately Invoked Function Expression）————    (function foo( ) {…..} ) ( )  </strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">//2</span></span><br><span class="line"><span class="comment">//------------------------------------------完全相同</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line">&#125;());</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params">gobal</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">console</span>.log(gobal.a) <span class="comment">//2</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//倒置代码运行顺序</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params">def</span>)</span>&#123;</span><br><span class="line">    def(<span class="built_in">window</span>);</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params"> global </span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( a );</span><br><span class="line">    <span class="built_in">console</span>.log( global.a );</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="1-4-块作用域"><a href="#1-4-块作用域" class="headerlink" title="1.4 块作用域"></a>1.4 块作用域</h2><h3 id="1-4-1-with"><a href="#1-4-1-with" class="headerlink" title="1.4.1 with"></a>1.4.1 with</h3><h3 id="1-4-2-try-catch"><a href="#1-4-2-try-catch" class="headerlink" title="1.4.2 try/catch"></a>1.4.2 try/catch</h3><h3 id="1-4-3-let"><a href="#1-4-3-let" class="headerlink" title="1.4.3 let"></a>1.4.3 let</h3><p><strong>只能定义在块级作用域内</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">   <span class="keyword">var</span> q = i;</span><br><span class="line">   a[i]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(q)&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">0</span>]()</span><br></pre></td></tr></table></figure><p>​    其中，由于for循环并不是一个函数体，所以for循环中定义的变量q和i是作用域for循环所在的函数体，和a同级，i++ 和  q=i 并不是重新定义变量，只是重复赋值，最终循环结束，i = 10,q=9;  由于function(){console.log(q)} 并不是立即执行，所以这里的q一直是存储的内存引用，最终所有的a[ i ] ( )都是输出 9，不过，在es6中新增了let命令声明变量，用法和var类似，不过let所声明的变量，只在let命令所在的代码块有效果，for循环的计数器中就很适合let命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">   ley q = i;</span><br><span class="line">   a[i]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(q)&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>]()  </span><br><span class="line"><span class="comment">//这里会输出   6  let声明的变量仅在块级作用域有效，所以这里的i只在本轮循环有效果，每次循环的i其实都是一个新的变量</span></span><br></pre></td></tr></table></figure><h3 id="1-4-4-const"><a href="#1-4-4-const" class="headerlink" title="1.4.4 const"></a>1.4.4 const</h3><p>其值是固定的（常量），之后任何试图修改值得操作都会引起错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = ture;</span><br><span class="line"><span class="keyword">if</span>(foo)&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> b = <span class="number">3</span>;   <span class="comment">//包含在if中的块作用域常量</span></span><br><span class="line">    </span><br><span class="line">    a = <span class="number">3</span>; <span class="comment">//正确；</span></span><br><span class="line">    b = <span class="number">4</span>; <span class="comment">//错误；</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//ReferenceError!</span></span><br></pre></td></tr></table></figure><h2 id="1-5变量提升"><a href="#1-5变量提升" class="headerlink" title="1.5变量提升"></a>1.5变量提升</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//2;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>编译器默认将var a提至最前端声明（变量提升）</p><p><strong>只有声明本身会被提升，而赋值或其他运行逻辑会留在原地，如果 提升改变了代码执行的顺序，会造成非常严重的破坏</strong></p><ul><li><strong>函数声明会被提升，但是函数表达式不会被提升</strong></li><li><strong>函数优先</strong>—————<strong>函数首先被提升，之后才是变量</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">//1</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>出现在后面的函数声明会覆盖前面的</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">//3</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>疑问 ！！！！！！！！！！！！这里的foo是函数声明还是函数表达式</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line">    <span class="keyword">var</span> a = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(a)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="1-6作用域闭包"><a href="#1-6作用域闭包" class="headerlink" title="1.6作用域闭包"></a>1.6作用域闭包</h2><p>​    <strong>无论通过使用任何手段将内部函数传递到所在的词法作用域外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包</strong></p><ul><li><strong>内部作用域不会消失</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6 6 6 6 6 6 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i&lt;= <span class="number">5</span>; i++)&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;,i*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6 6 6 6 6 6 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i&lt;= <span class="number">5</span>; i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;,i*<span class="number">1000</span>);</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0 1 2 3 4 5</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i&lt;= <span class="number">5</span>; i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> j = i</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j);</span><br><span class="line">        &#125;,j*<span class="number">1000</span>);</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">需要给每个闭包一个单独的块作用域，使之存储自己的变量</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i&lt;= <span class="number">5</span>; i++)&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;,i*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-7-模块"><a href="#1-7-模块" class="headerlink" title="1.7 模块"></a>1.7 模块</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> something = <span class="string">"cool"</span>;</span><br><span class="line">    <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( something );</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(another.join(<span class="string">"!"</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = CoolModule();</span><br><span class="line">foo.doSomething(); <span class="comment">//cool</span></span><br><span class="line">foo.doAnother(); <span class="comment">//1!2!3</span></span><br></pre></td></tr></table></figure><p>模块模式需要具备两个条件：</p><ol><li>必须有外部的封装函数，函数必须至少被调用一次（每次调用都会创建一个新的模块实例）；</li><li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li></ol><h1 id="2-JS和对象原型"><a href="#2-JS和对象原型" class="headerlink" title="2 JS和对象原型"></a>2 JS和对象原型</h1><h2 id="2-1-this"><a href="#2-1-this" class="headerlink" title="2.1 this"></a>2.1 this</h2>]]></content>
    
    <summary type="html">
    
      你不知道的JavaScript读书笔记
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Javascript知识点</title>
    <link href="http://yoursite.com/2018/03/18/JS%20MS/"/>
    <id>http://yoursite.com/2018/03/18/JS MS/</id>
    <published>2018-03-17T16:00:00.000Z</published>
    <updated>2018-04-09T13:16:13.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="原型-原型链"><a href="#原型-原型链" class="headerlink" title="原型 原型链"></a>原型 原型链</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.class = <span class="string">'class-1'</span>;</span><br><span class="line">  <span class="comment">//return this //默认存在</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'szw'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="comment">//var f1 = new Foo('list', 21)</span></span><br></pre></td></tr></table></figure><ul><li><p>var a = {} 其实是var a = new Object()的语法糖</p></li><li><p>var a = []其实是var a = new Arrayt()的语法糖</p></li><li><p>function Foo(){…}其实是 var Foo = new Function(…)</p></li><li><p>使用instanceof判断一个函数是否是一个变量的构造函数</p></li></ul><h3 id="原型规则和示例"><a href="#原型规则和示例" class="headerlink" title="原型规则和示例"></a>原型规则和示例</h3><ul><li>所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（除了“null”以外）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.a = <span class="number">100</span>; <span class="comment">//可扩展</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr.a = <span class="number">100</span>; <span class="comment">//可扩展</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">fn.a = <span class="number">100</span>; <span class="comment">//可扩展</span></span><br></pre></td></tr></table></figure><ul><li>所有的引用类型（数组、对象、函数），都有一个_ proto _（隐式原型）属性，属性值是一个普通的对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj._proto_);</span><br><span class="line"><span class="built_in">console</span>.log(arr._proto_);</span><br><span class="line"><span class="built_in">console</span>.log(fn._proto_);</span><br></pre></td></tr></table></figure><ul><li>所有的函数，都有一个prototype（显试原型）属性，属性值也是一个普通的对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn.prototype);</span><br></pre></td></tr></table></figure><ul><li>所有的引用类型（数组、对象、函数），_ proto _属性值指向它的构造函数的prototype属性值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj._proto_ === <span class="built_in">Object</span>.prototype);</span><br></pre></td></tr></table></figure><ul><li>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的_ proto _（即它的构造函数的prototype）中寻找</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.alertName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建示例</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'szw'</span>);</span><br><span class="line">f.printName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">f.printName();</span><br><span class="line">f.alertName();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item;</span><br><span class="line"><span class="keyword">for</span>(item <span class="keyword">in</span> f)&#123;</span><br><span class="line">  <span class="keyword">if</span>(f.hasOwnProperty(item))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>instanceof 用于判断引用类型属于哪个构造函数</li></ul><h2 id="作用域-闭包"><a href="#作用域-闭包" class="headerlink" title="作用域 闭包"></a>作用域 闭包</h2><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ol><li>this 要在执行时才能确认值，定义时无法确认</li><li>作为构造函数执行</li><li>作为对象属性执行</li><li>作为普通函数执行</li><li>call apply bind</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'szw'</span>);</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="keyword">var</span> obj =&#123;</span><br><span class="line">  name: <span class="string">'A'</span>;</span><br><span class="line">  printName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.printName(); <span class="comment">//'A'</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)  <span class="comment">//this === windows</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  alert(name)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn1.call(&#123;<span class="attr">x</span>:<span class="number">100</span>&#125;,<span class="string">'szw'</span>) <span class="comment">//this-&gt;Object &#123;x:100&#125;  apply相同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  alert(name)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;.bind(&#123;<span class="attr">y</span>:<span class="number">200</span>&#125;)</span><br><span class="line">fn2(<span class="string">'szw'</span>); <span class="comment">//this -&gt;&#123;y:200&#125;</span></span><br></pre></td></tr></table></figure><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul><li>无块级作用域</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'szw'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br></pre></td></tr></table></figure><ul><li>函数和全局作用域</li></ul><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">200</span>;</span><br><span class="line">  <span class="comment">//当前作用域没有定义的变量，即‘自由变量’</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul><li>函数作为返回值</li><li>函数作为参数传递</li><li>主要应用于封装变量、收揽权限</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">//返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//f1得到一个函数</span></span><br><span class="line"><span class="keyword">var</span> f1 = F1();</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">200</span>;</span><br><span class="line">f1(); <span class="comment">//100</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">//返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//f1得到一个函数</span></span><br><span class="line"><span class="keyword">var</span> f1 = F1();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F2</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">200</span>;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">F2(f1); <span class="comment">//100</span></span><br></pre></td></tr></table></figure><h2 id="异步-单线程"><a href="#异步-单线程" class="headerlink" title="异步 单线程"></a>异步 单线程</h2><h3 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h3><h4 id="何时需要异步"><a href="#何时需要异步" class="headerlink" title="何时需要异步"></a>何时需要异步</h4><ul><li><p>在可能发生等待的情况</p><p>定时请求： setTimeOut、setInveral</p><p>网络请求：AJAX、动态<img>加载</p><p>事件绑定</p></li><li><p>等待过程中不能像alert 一样阻塞程序运行</p><p>img加载示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'star'</span>);</span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(img);</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'loaded'</span>)</span><br><span class="line">&#125;</span><br><span class="line">img.src = <span class="string">'1.jpg'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(img.src);</span><br></pre></td></tr></table></figure><p>​</p></li></ul><h3 id="前端使用异步场景"><a href="#前端使用异步场景" class="headerlink" title="前端使用异步场景"></a>前端使用异步场景</h3><h3 id="异步和单线程"><a href="#异步和单线程" class="headerlink" title="异步和单线程"></a>异步和单线程</h3><h1 id="JS-API"><a href="#JS-API" class="headerlink" title="JS API"></a>JS API</h1><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><ul><li>forEach 遍历所有元素</li><li>every 判断所有元素是否符合条件</li><li>some 判断是否至少有一个元素符合条件</li><li>sort 排序</li><li>map 对元素重新组装，生成新数组</li><li>filter 过滤符合条件的元素</li></ul><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ul><li>协议、端口、域名   有一个不同就算跨域</li><li>img、link、script 3个标签允许跨域请求</li><li>解决： JOSNP http-header</li></ul><h3 id="xmlHttpRequest"><a href="#xmlHttpRequest" class="headerlink" title="xmlHttpRequest"></a>xmlHttpRequest</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">"GET"</span>, <span class="string">"/api"</span>, <span class="literal">false</span>)</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="comment">//0未初始化</span></span><br><span class="line">    <span class="comment">//1载入</span></span><br><span class="line">    <span class="comment">//2载入完成</span></span><br><span class="line">    <span class="comment">//3交互</span></span><br><span class="line">    <span class="comment">//4完成</span></span><br><span class="line">    <span class="keyword">if</span>(xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line">      <span class="comment">//2xx 完成</span></span><br><span class="line">      <span class="comment">//3xx 重定向</span></span><br><span class="line">      <span class="comment">//4xx 客户端请求错误</span></span><br><span class="line">      <span class="comment">//5xx 服务端请求错误</span></span><br><span class="line">      alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="状态码说明"><a href="#状态码说明" class="headerlink" title="状态码说明"></a>状态码说明</h3><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><h3 id="通用事件绑定"><a href="#通用事件绑定" class="headerlink" title="通用事件绑定"></a>通用事件绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn1'</span>);</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'clicked'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params">elem,type,fn</span>)</span>&#123;</span><br><span class="line">  elem.addEventListener(type,fn)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">'link1'</span>);</span><br><span class="line">bindEvent(a,<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  e.preventDefaule();  <span class="comment">//阻止默认行为</span></span><br><span class="line">  alter(<span class="string">'clicked'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用事件绑定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params">elem, type, select, fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(fn == <span class="literal">null</span>)&#123;</span><br><span class="line">    fn = select;</span><br><span class="line">    select = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  elem.addEventListener(type,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; <span class="comment">//添加事件</span></span><br><span class="line">    <span class="keyword">var</span> target;</span><br><span class="line">    <span class="keyword">if</span>(select)&#123;</span><br><span class="line">      target = e.target； <span class="comment">//返回事件元素</span></span><br><span class="line">      <span class="keyword">if</span>(target.matches(select))&#123; <span class="comment">//target是否符合目标元素</span></span><br><span class="line">        fn.call(target, e); <span class="comment">//this-&gt;target</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      fn(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用代理</span></span><br><span class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>);</span><br><span class="line">bindEvent(div1, <span class="string">'click'</span>, <span class="string">'a'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.innerHTML)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//不使用代理</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">'a1'</span>);</span><br><span class="line">bindEvent(a, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a.innerHTML)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><p>##版本管理</p><p>##模块化</p><p>##打包工具</p><h1 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h1><p>##页面渲染</p><p>##性能优化</p><p>#变量类型和计算</p><h1 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h1>]]></content>
    
    <summary type="html">
    
      面试专用
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="面经" scheme="http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>面试</title>
    <link href="http://yoursite.com/2018/03/16/%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2018/03/16/面试/</id>
    <published>2018-03-15T16:00:00.000Z</published>
    <updated>2018-04-09T13:28:31.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="手写一个js继承"><a href="#手写一个js继承" class="headerlink" title="手写一个js继承"></a>手写一个js继承</h2><p>​    继承、<strong>prototype</strong> ——<a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" target="_blank" rel="noopener">阮一峰解释</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DOG</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dogA = <span class="keyword">new</span> DOG(<span class="string">'大毛'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dogA.name); <span class="comment">// 大毛</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原型继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DOG</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">DOG.prototype = &#123; <span class="attr">species</span> : <span class="string">'犬科'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dogA = <span class="keyword">new</span> DOG(<span class="string">'大毛'</span>);</span><br><span class="line"><span class="keyword">var</span> dogB = <span class="keyword">new</span> DOG(<span class="string">'二毛'</span>);</span><br><span class="line"></span><br><span class="line">alert(dogA.species); <span class="comment">// 犬科</span></span><br><span class="line">alert(dogB.species); <span class="comment">// 犬科</span></span><br></pre></td></tr></table></figure><h2 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h2><p>​    1. 浏览器客户端向本地DNS服务器发送一个含有域名<a href="http://www.cnblogs.com的DNS查询报文。本地DNS服务器把查询报文转发到根DNS服务器，根DNS服务器注意到其com后缀，于是向本地DNS服务器返回comDNS服务器的IP地址。本地DNS服务器再次向comDNS服务器发送查询请求，comDNS服务器注意到其www.cnblogs.com后缀并用负责该域名的权威DNS服务器的IP地址作为回应。最后，本地DNS服务器将含有www.cnblogs.com的IP地址的响应报文发送给客户端。" target="_blank" rel="noopener">www.cnblogs.com的DNS查询报文。本地DNS服务器把查询报文转发到根DNS服务器，根DNS服务器注意到其com后缀，于是向本地DNS服务器返回comDNS服务器的IP地址。本地DNS服务器再次向comDNS服务器发送查询请求，comDNS服务器注意到其www.cnblogs.com后缀并用负责该域名的权威DNS服务器的IP地址作为回应。最后，本地DNS服务器将含有www.cnblogs.com的IP地址的响应报文发送给客户端。</a></p><pre><code>2. 从客户端到本地服务器属于递归查询，而DNS服务器之间的交互属于迭代查询。</code></pre><p>​    3. 正常情况下，本地DNS服务器的缓存中已有comDNS服务器的地址，因此请求根域名服务器这一步不是必需的。</p><p><img src="/var/folders/9z/8xx9sv750sx31xn88v4x0bh80000gn/T/abnerworks.Typora/image-201803201219068.png" alt="mage-20180320121906"></p><p><img src="/var/folders/9z/8xx9sv750sx31xn88v4x0bh80000gn/T/abnerworks.Typora/image-201803201219158.png" alt="mage-20180320121915"></p><h2 id="浏览器布局渲染"><a href="#浏览器布局渲染" class="headerlink" title="浏览器布局渲染"></a>浏览器布局渲染</h2><p>​    根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，flutter改变DOM的外观样式以及大小和位置。这时就要提到两个重要概念：replaint和reflow。</p><p>​    1. replaint：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。</p><p>​    2. reflow： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是Reflow，或是Layout。</p><p>​    所以我们应该尽量减少reflow和replaint，我想这也是为什么现在很少有用table布局的原因之一。</p><p>​    最后浏览器绘制各个节点，将页面展示给用户。</p><h2 id="Let和const"><a href="#Let和const" class="headerlink" title="Let和const"></a>Let和const</h2><p>​    let声明的变量只在块级作用域内有效，用大括号括起来的部分都叫块级作用域。在块级作用域中不能用let重复声明相同的变量。</p><p>​    const用来声明常量，常量不允许修改。const也有块级作用域的概念，声明的时候必须赋值。let和const不能在同一级作用域内重复定义，const不能在同一级作用域内修改常量的值。在不同的块级作用域里面,可以声明重复的变量以及常量。<strong>如果用const去声明一个对象的时候，可以修改对象的值。</strong></p><p>​    let和const不存在变量提升，有暂时性死区，所以变量要提前声明</p><p>async 函数是什么？一句话，它就是 Generator 函数的语法糖。</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>​    客户端发送一个带有SYN标志的数据包给服务端，服务端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后客户端再回传一个带ACK标志的数据包，代表握手结束，连接成功。</p><p><img src="/var/folders/9z/8xx9sv750sx31xn88v4x0bh80000gn/T/abnerworks.Typora/image-201803201225514.png" alt="mage-20180320122551"></p><p>客户端：“你好，在家不，有你快递。”</p><p>服务端：“在的，送来就行。”</p><p>客户端：“好嘞。”</p><h2 id="四次握手"><a href="#四次握手" class="headerlink" title="四次握手"></a>四次握手</h2><p>​    为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求。与创建TCP连接的3次握手类似，关闭TCP连接，需要4次握手。</p><p><img src="/var/folders/9z/8xx9sv750sx31xn88v4x0bh80000gn/T/abnerworks.Typora/image-201803201227054.png" alt="mage-20180320122705"></p><p>客户端：“兄弟，我这边没数据要传了，咱关闭连接吧。”</p><p>服务端：“收到，我看看我这边有木有数据了。”</p><p>服务端：“兄弟，我这边也没数据要传你了，咱可以关闭连接了。”</p><p>客户端：“好嘞。”</p><h2 id="HTTPs"><a href="#HTTPs" class="headerlink" title="HTTPs"></a>HTTPs</h2><p>HTTPS 通过安全协议如SSL/TLS 来保证数据传输, SSL和TLS都是基于非对称加密算法，而RSA算法是非对称加密算法中的佼佼者。</p><p>SSL证书工作的过程：</p><ul><li>当浏览器或服务器尝试连接支持支持SSL的网络服务器时，浏览器或服务器会要求网络服务器表明自己的身份。</li><li>网络服务器发送一份自身持有的SSL证书给浏览器或服务器，浏览器或服务器根据一定的规则(和本地存储的CA根证书列表对比) 判断是否信任远程服务，如果信任，则发送一份消息给远程服务器，否则中断继续连接。</li><li>网络服务器接收到消息后，发送一份包含数字签名的确认信息，开始建立SSL加密的会话。</li><li>会话建立后，加密的数据顺畅地在客户端和网络服务器之间传递。</li></ul><h2 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别"></a>HTTPS和HTTP的区别</h2><p>​    超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。<br>    为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。<br>HTTPS和HTTP的区别主要为以下四点：<br>    一、https协议需要到ca申请证书，一般免费证书很少，需要交费。<br>    二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。<br>    三、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。<br>    四、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><p> <strong>缓存过程：</strong></p><ul><li>当一个用户发起一个静态资源请求的时候,浏览器会通过以下几步来获取资源</li><li>当第一次发送请求，http返回200的状态码，</li><li>如果没有关闭缓存请求的话（没标明不使用缓存，下述）则会在返回头中返回包含last-Modified以及Etag和Expires的字段（这些字段下面慢慢说），然后将文件保存在Cache目录下；</li><li>当后续请求该文件时候，先在本地查找该资源,如果在本地缓存找到对应的资源,但是不知道该资源是否过期或者已经过期, 则发一个http请求到服务器,然后服务器判断这个请求,</li><li>如果请求的资源在服务器上没有改动过,则返回304, 让浏览器使用本地找到的那个资源</li><li>而如果当服务器发现请求的资源已经修改过,或者这是一个新的请求(本地无对应资源),服务器则返回该资源的数据,并且返回200,</li><li>当然这个是指找到资源的情况下,如果服务器上没有这个资源,则返回404</li></ul><h2 id="xmlHttpRequest"><a href="#xmlHttpRequest" class="headerlink" title="xmlHttpRequest"></a>xmlHttpRequest</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">"GET"</span>, <span class="string">"/api"</span>, <span class="literal">false</span>)</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="comment">//0未初始化</span></span><br><span class="line">    <span class="comment">//1载入</span></span><br><span class="line">    <span class="comment">//2载入完成</span></span><br><span class="line">    <span class="comment">//3交互</span></span><br><span class="line">    <span class="comment">//4完成</span></span><br><span class="line">    <span class="keyword">if</span>(xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line">      <span class="comment">//2xx 完成</span></span><br><span class="line">      <span class="comment">//3xx 重定向</span></span><br><span class="line">      <span class="comment">//4xx 客户端请求错误</span></span><br><span class="line">      <span class="comment">//5xx 服务端请求错误</span></span><br><span class="line">      alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">                type: <span class="string">"get"</span>, <span class="comment">// 请求类型（get/post）</span></span><br><span class="line">                url: <span class="string">"你的请求路径－url"</span>, </span><br><span class="line">                <span class="keyword">async</span>: <span class="literal">true</span>, <span class="comment">// 是否异步</span></span><br><span class="line">                dataType: <span class="string">"json"</span>, <span class="comment">// 设置数据类型</span></span><br><span class="line">                success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>)</span>&#123;</span><br><span class="line">                    <span class="comment">// 请求成功后的回调方法，进行数据赋值、显示等操作</span></span><br><span class="line">                &#125;,</span><br><span class="line">                error: <span class="function"><span class="keyword">function</span> (<span class="params">errorMsg</span>)</span>&#123;</span><br><span class="line">                    <span class="comment">// 请求失败</span></span><br><span class="line">                    alert(<span class="string">"请求失败"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><h2 id="CSS清除浮动"><a href="#CSS清除浮动" class="headerlink" title="CSS清除浮动"></a>CSS清除浮动</h2><ol><li><p>clear清除浮动（添加空div法）</p></li><li><p>给浮动元素父级<strong>设置高度</strong>    缺点：在浮动元素高度不确定的时候不适用</p></li><li><p>以浮制浮（<strong>父级同时浮动</strong>）  缺点：需要给每个浮动元素父级添加浮动，浮动多了容易出现问题。</p></li><li><p><strong>父级设置成inline-block</strong>   缺点：父级的margin左右auto失效，无法使用margin: 0 auto;居中了</p></li><li><p><strong>br</strong> 清浮动   br 标签自带clear属性，将它设置成both其实和添加空div原理是一样的</p></li><li><p>给父级添加<strong>overflow:hidden</strong> 清浮动方法   问题：需要配合 宽度 或者 zoom 兼容IE6 IE7；</p></li><li><p>万能清除法 <strong>after伪类</strong> 清浮动（现在<strong>主流</strong>方法，<strong>推荐使用</strong>）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">"."</span>;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">overflow</span>:hidden;</span><br><span class="line"><span class="attribute">visibility</span>:hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">after</span>伪类： 元素内部末尾添加内容；</span><br><span class="line">    :after&#123;content"添加的内容";&#125; IE6，7下不兼容</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">zoom</span> 缩放 </span><br><span class="line">    <span class="selector-tag">a</span>、触发 <span class="selector-tag">IE</span>下 <span class="selector-tag">haslayout</span>，使元素根据自身内容计算宽高。</span><br><span class="line">    <span class="selector-tag">b</span>、<span class="selector-tag">FF</span> 不支持；</span><br></pre></td></tr></table></figure></li></ol><h2 id="positon"><a href="#positon" class="headerlink" title="positon"></a>positon</h2><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>absolute</td><td>生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td></tr><tr><td>fixed</td><td>生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td></tr><tr><td>relative</td><td>生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</td></tr><tr><td>static</td><td>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 position 属性的值。</td></tr></tbody></table><h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>此元素不会被显示。</td></tr><tr><td>block</td><td>此元素将显示为块级元素，此元素前后会带有换行符。</td></tr><tr><td>inline</td><td>默认。此元素会被显示为内联元素，元素前后没有换行符。</td></tr><tr><td>inline-block</td><td>行内块元素。（CSS2.1 新增的值）</td></tr><tr><td>list-item</td><td>此元素会作为列表显示。</td></tr><tr><td>run-in</td><td>此元素会根据上下文作为块级元素或内联元素显示。</td></tr><tr><td>compact</td><td>CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</td></tr><tr><td>marker</td><td>CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</td></tr><tr><td>table</td><td>此元素会作为块级表格来显示（类似 <table>），表格前后带有换行符。</table></td></tr><tr><td>inline-table</td><td>此元素会作为内联表格来显示（类似 <table>），表格前后没有换行符。</table></td></tr><tr><td>table-row-group</td><td>此元素会作为一个或多个行的分组来显示（类似 <tbody>）。</tbody></td></tr><tr><td>table-header-group</td><td>此元素会作为一个或多个行的分组来显示（类似 <thead>）。</thead></td></tr><tr><td>table-footer-group</td><td>此元素会作为一个或多个行的分组来显示（类似 <tfoot>）。</tfoot></td></tr><tr><td>table-row</td><td>此元素会作为一个表格行显示（类似 </td></tr><tr>）。</tr><tr><td>table-column-group</td><td>此元素会作为一个或多个列的分组来显示（类似 <colgroup>）。</colgroup></td></tr><tr><td>table-column</td><td>此元素会作为一个单元格列显示（类似 <col>）</td></tr><tr><td>table-cell</td><td>此元素会作为一个表格单元格显示（类似 </td><td> 和 <th>）</th></td></tr><tr><td>table-caption</td><td>此元素会作为一个表格标题显示（类似 <caption>）</caption></td></tr><tr><td>inherit</td><td>规定应该从父元素继承 display 属性的值。</td></tr></tbody></table><h2 id="响应式节点"><a href="#响应式节点" class="headerlink" title="响应式节点"></a>响应式节点</h2><ol><li>1170px（大屏幕 大桌面显示器）</li><li>970px（中等屏幕  桌面显示器）</li><li>750px（小屏幕 平板）</li><li>小于768px （超小 <a href="https://www.baidu.com/s?wd=%E6%89%8B%E6%9C%BA%E5%B1%8F%E5%B9%95&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1d9uj9hnvF-PjbduywWuyP-0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnHbzPjbYnH01rHf3P1m3PjRsPs" target="_blank" rel="noopener">手机屏幕</a>）</li></ol><h2 id="react和vue的区别"><a href="#react和vue的区别" class="headerlink" title="react和vue的区别"></a>react和vue的区别</h2><ol><li><strong>Virtual DOM</strong><ul><li>Vue宣称可以<a href="https://vuejs.org/v2/guide/comparison.html#Performance" target="_blank" rel="noopener">更快地计算出Virtual DOM的差异</a>，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。<a href="http://caibaojian.com/vue-vs-react.html" target="_blank" rel="noopener">·</a></li><li>而对于React而言，<a href="https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate" target="_blank" rel="noopener">每当应用的状态被改变时</a>，全部子组件都会重新渲染。当然，这可以通过<code>shouldComponentUpdate</code>这个生命周期方法来进行控制，但Vue将此视为<a href="https://vuejs.org/v2/guide/comparison.html#Optimization-Efforts" target="_blank" rel="noopener">默认的优化</a>。</li></ul></li><li><strong>模板 vs JSX</strong></li></ol><h2 id="react组件生命周期"><a href="#react组件生命周期" class="headerlink" title="react组件生命周期"></a>react组件生命周期</h2><ul><li>Mounting：已插入真实 DOM</li><li>Updating：正在被重新渲染</li><li>Unmounting：已移出真实 DOM</li></ul><h2 id="VUE生命周期"><a href="#VUE生命周期" class="headerlink" title="VUE生命周期"></a>VUE生命周期</h2><h2 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h2><p>　　只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p><p>　　ES6明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><p>　　总之，在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p><p>　　“暂时性死区”也意味着<code>typeof</code>不再是一个百分之百安全的操作（会使typeof报错）。</p><p>　　总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，<strong>但是不可获取</strong>，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><h2 id="CSS-元素垂直居中"><a href="#CSS-元素垂直居中" class="headerlink" title="CSS 元素垂直居中"></a>CSS 元素垂直居中</h2><ol><li>不知道自己高度和父容器高度的情况下, 利用绝对定位只需要以下三行：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">parentElement</span>&#123;</span><br><span class="line">        <span class="attribute">position</span>:relative;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="selector-tag">childElement</span>&#123;</span><br><span class="line">        <span class="attribute">position</span>: absolute;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">        <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>若父容器下只有一个元素，且父元素设置了高度，则只需要使用相对定位即可</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">parentElement</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:xxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.childElement</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>Flex 布局：</strong></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">parentElement</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:flex;<span class="comment">/*Flex布局*/</span></span><br><span class="line">    <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">    <span class="attribute">align-items</span>:center;<span class="comment">/*指定垂直居中*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Cookie、localStorage、sessionStorage的区别"><a href="#Cookie、localStorage、sessionStorage的区别" class="headerlink" title="Cookie、localStorage、sessionStorage的区别"></a>Cookie、localStorage、sessionStorage的区别</h2><ol><li><p>cookie</p><p>​    Cookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右，是网景公司的前雇员 Lou Montulli 在1993年3月的发明。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。</p></li></ol><ol start="2"><li><p>localStorage</p><p>​    localStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于<strong>本地存储</strong>，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。</p></li><li><p>sessionStorage</p><p>​    sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。</p></li><li><p>三者异同</p><p>| 特性           | Cookie                                                       | localStorage                                                | sessionStorage                               |<br>| ————– | ———————————————————— | ———————————————————– | ——————————————– |<br>| 数据的生命期   | 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 | 除非被清除，否则永久保存                                    | 仅在当前会话下有效，关闭页面或浏览器后被清除 |<br>| 存放数据大小   | 4K左右                                                       | 一般为5MB                                                   |                                              |<br>| 与服务器端通信 | 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 | 仅在客户端（即浏览器）中保存，不参与和服务器的通信          |                                              |<br>| 易用性         | 需要程序员自己封装，源生的Cookie接口不友好                   | 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 |                                              |</p><p>​    cookie 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效,存放数据大小一般4K左右，而sessionStorage与localStorage大小在5兆左右，在客户端生成，localStorage除非被清除，否则会永久保存，sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除，cookie在与服务器端通信每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题,而sessionStorage与localStorage仅在客户端（即浏览器）中保存，不参与和服务器的通信。</p><ol><li>cookie由服务端生成，用于标识用户身份；而两个storage用于浏览器端缓存数据</li><li>三者都是键值对的集合</li><li>一般情况下浏览器端不会修改cookie，但会频繁操作两个storage</li><li>如果保存了cookie的话，http请求中一定会带上；而两个storage可以由脚本选择性的提交</li><li>会话的storage会在会话结束后销毁；而local的那个会永久保存直到覆盖。cookie会在过期时间之后销毁。</li><li>安全性方面，cookie中最好不要放置任何明文的东西。两个storage的数据提交后在服务端一定要校验（其实任何payload和qs里的参数都要校验）。</li></ol></li></ol><h2 id="JS的事件模型就是一种观察者模式的体现，当对应的事件被触发时，监听该事件的所有监听函数都会被调用。"><a href="#JS的事件模型就是一种观察者模式的体现，当对应的事件被触发时，监听该事件的所有监听函数都会被调用。" class="headerlink" title="JS的事件模型就是一种观察者模式的体现，当对应的事件被触发时，监听该事件的所有监听函数都会被调用。"></a>JS的事件模型就是一种观察者模式的体现，当对应的事件被触发时，监听该事件的所有监听函数都会被调用。</h2>]]></content>
    
    <summary type="html">
    
      面试专用
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="面经" scheme="http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>css面试知识点</title>
    <link href="http://yoursite.com/2018/03/13/CSS/"/>
    <id>http://yoursite.com/2018/03/13/CSS/</id>
    <published>2018-03-12T16:00:00.000Z</published>
    <updated>2018-04-09T13:28:27.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="css盒子模型"><a href="#css盒子模型" class="headerlink" title="css盒子模型"></a>css盒子模型</h1><h2 id="基本概念：-基本模型-IE模型"><a href="#基本概念：-基本模型-IE模型" class="headerlink" title="基本概念： 基本模型+IE模型"></a>基本概念： 基本模型+IE模型</h2><h3 id="标准模型和IE模型的区别"><a href="#标准模型和IE模型的区别" class="headerlink" title="标准模型和IE模型的区别"></a>标准模型和IE模型的区别</h3><ul><li>两者的区别在于content的不同，IE盒模型的content包括border、padding</li><li>IE模型：really height  = border+ padding + content</li></ul><p>​    box-sizing: border-box </p><ul><li>标准模型：really height = content</li></ul><p>​    box-sizing: content-box(默认)</p><h3 id="js如何获取盒模型对应的宽和高"><a href="#js如何获取盒模型对应的宽和高" class="headerlink" title="js如何获取盒模型对应的宽和高"></a>js如何获取盒模型对应的宽和高</h3><ul><li><p>dom.style.width/height</p><p>只能取内联样式的宽高（head style/link 不能用）</p></li><li><p>Dom.currentStyle.width/height</p><p>取渲染后的宽高（仅IE支持）</p></li><li><p>Windows.getComputedStyle(dom).width/height</p><p>取渲染后的宽高 兼容性更好</p></li><li><p>Dom.getBoundingClientReact().widrh/height</p><p>计算元素绝对位置 </p></li></ul><h2 id="BFC–块级格式化上下文"><a href="#BFC–块级格式化上下文" class="headerlink" title="BFC–块级格式化上下文"></a>BFC–块级格式化上下文</h2><p>​</p>]]></content>
    
    <summary type="html">
    
      css面试知识点
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="面经" scheme="http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>面试题</title>
    <link href="http://yoursite.com/2018/03/13/%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    <id>http://yoursite.com/2018/03/13/编程题/</id>
    <published>2018-03-12T16:00:00.000Z</published>
    <updated>2018-04-09T13:16:17.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="封装函数-f，使-f-的-this-指向指定的对象"><a href="#封装函数-f，使-f-的-this-指向指定的对象" class="headerlink" title="封装函数 f，使 f 的 this 指向指定的对象"></a>封装函数 f，使 f 的 this 指向指定的对象</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindThis</span>(<span class="params">f, oTarget</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f.bind)&#123;</span><br><span class="line">        <span class="keyword">return</span> f.bind(oTarget);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            f.apple(oTarget,<span class="built_in">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>知识点</strong></p><ul><li><p>bind()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">  x: <span class="number">42</span>,</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> retrieveX = <span class="built_in">module</span>.getX;</span><br><span class="line"><span class="built_in">console</span>.log(retrieveX()); </span><br><span class="line"><span class="comment">// The function gets invoked at the global scope</span></span><br><span class="line"><span class="comment">//函数被全局调用</span></span><br><span class="line"><span class="comment">// expected output: undefined</span></span><br><span class="line"><span class="comment">//输出underfined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boundGetX = retrieveX.bind(<span class="built_in">module</span>);</span><br><span class="line"><span class="built_in">console</span>.log(boundGetX());</span><br><span class="line"><span class="comment">// expected output: 42</span></span><br></pre></td></tr></table></figure><p>​</p></li></ul><p>​    </p>]]></content>
    
    <summary type="html">
    
      js的少量面试题
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试提纲</title>
    <link href="http://yoursite.com/2018/03/13/%E6%8F%90%E7%BA%B2/"/>
    <id>http://yoursite.com/2018/03/13/提纲/</id>
    <published>2018-03-12T16:00:00.000Z</published>
    <updated>2018-04-09T13:16:07.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>这部分应该有很多同学觉得都不用准备，但是事实上面试官第一个问题如果回答的没有条理不仅面试官的印象会不好，而且对自己接下来的状态也会有很大的影响。所以面试者最好自己写好自我介绍的草稿，设计到的内容包括但不限于<strong>为什么学前端？拿过什么样的奖项之类的？</strong>，虽然简历中有写。</p><p>接着面试官可能会问：</p><ul><li>如何学前端的？</li><li>你认为的前端都要做什么样的工作？</li><li>你理解的前端工程师是什么？</li><li>你认为前端工程师对于用户和公司有哪些作用？</li><li>你最近遇到过什么技术挑战？你是如何解决的？</li><li>项目中遇到的问题是如何解决的？</li><li>平时都是怎么学习的？</li><li>实习了多久，在哪实习，实习的工作是什么？</li><li>实习过程中能不能完成公司给你的工作？工作量如何？</li><li>…</li></ul><p>好了，前戏差不多了，现在开始划一下基础知识的重点。</p><h2 id="知识点汇总"><a href="#知识点汇总" class="headerlink" title="知识点汇总"></a>知识点汇总</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><ul><li>HTML5新特性，语义化</li><li>浏览器的标准模式和怪异模式</li><li>xhtml和html的区别</li><li>使用data-的好处</li><li>meta标签</li><li>canvas</li><li>HTML废弃的标签</li><li>IE6 bug，和一些定位写法</li><li>css js放置位置和原因</li><li>什么是渐进式渲染</li><li>html模板语言</li><li>meta viewport原理</li></ul><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ul><li>盒模型，box-sizing</li><li>CSS3新特性，伪类，伪元素，锚伪类</li><li>CSS实现隐藏页面的方式</li><li>如何实现水平居中和垂直居中。</li><li>说说position，display</li><li>请解释*{box-sizing:border-box;}的作用，并说明使用它的好处</li><li>浮动元素引起的问题和解决办法？绝对定位和相对定位，元素浮动后的display值</li><li>link和@import引入css的区别</li><li>解释一下css3的flexbox，以及适用场景</li><li>inline和inline-block的区别</li><li>哪些是块级元素那些是行级元素，各有什么特点</li><li>grid布局</li><li>table布局的作用</li><li>实现两栏布局有哪些方法？</li><li>css dpi</li><li>你知道attribute和property的区别么</li><li>css布局问题？css实现三列布局怎么做？如果中间是自适应又怎么做？</li><li>流式布局如何实现，响应式布局如何实现</li><li>移动端布局方案</li><li>实现三栏布局（圣杯布局，双飞翼布局，flex布局）</li><li>清除浮动的原理</li><li>overflow:hidden有什么缺点？</li><li>padding百分比是相对于父级宽度还是自身的宽度</li><li>css3动画，transition和animation的区别，animation的属性，加速度，重力的模拟实现</li><li>CSS 3 如何实现旋转图片（transform: rotate）</li><li>sass less</li><li>对移动端开发了解多少？（响应式设计、Zepto；@media、viewport、JavaScript 正则表达式判断平台。）</li><li>什么是bfc，如何创建bfc？解决什么问题？</li><li>CSS中的长度单位（px,pt,rem,em,ex,vw,vh,vh,vmin,vmax）</li><li>CSS 选择器的优先级是怎样的？</li><li>雪碧图</li><li>svg</li><li>媒体查询的原理是什么？</li><li>CSS 的加载是异步的吗？表现在什么地方？</li><li>常遇到的浏览器兼容性问题有哪些？常用的hack的技巧</li><li>外边距合并</li><li>解释一下“::before”和“:after”中的双冒号和单冒号的区别</li></ul><h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><ul><li>js的基本类型有哪些？引用类型有哪些？null和undefined的区别。</li><li>如何判断一个变量是Array类型？如何判断一个变量是Number类型？（都不止一种）</li><li>Object是引用类型嘛？引用类型和基本类型有什么区别？哪个是存在堆哪一个是存在栈上面的？</li><li>JS常见的dom操作api</li><li>解释一下事件冒泡和事件捕获</li><li>事件委托（手写例子），事件冒泡和捕获，如何阻止冒泡？如何组织默认事件？</li><li>对闭包的理解？什么时候构成闭包？闭包的实现方法？闭包的优缺点？</li><li>this有哪些使用场景？跟C,Java中的this有什么区别？如何改变this的值？</li><li>call，apply，bind</li><li>显示原型和隐式原型，手绘原型链，原型链是什么？为什么要有原型链</li><li>创建对象的多种方式</li><li>实现继承的多种方式和优缺点</li><li>new 一个对象具体做了什么</li><li>手写Ajax，XMLHttpRequest</li><li>变量提升</li><li>举例说明一个匿名函数的典型用例</li><li>指出JS的宿主对象和原生对象的区别，为什么扩展JS内置对象不是好的做法？有哪些内置对象和内置函数？</li><li>attribute和property的区别</li><li>document load和document DOMContentLoaded两个事件的区别</li><li>=== 和 == , [] === [], undefined === undefined,[] == [], undefined == undefined</li><li>typeof能够得到哪些值</li><li>什么是“use strict”,好处和坏处</li><li>函数的作用域是什么？js 的作用域有几种？ </li><li>JS如何实现重载和多态</li><li>常用的数组api，字符串api</li><li>原生事件绑定（跨浏览器），dom0和dom2的区别？</li><li>给定一个元素获取它相对于视图窗口的坐标</li><li>如何实现图片滚动懒加载</li><li>js 的字符串类型有哪些方法？ 正则表达式的函数怎么使用？</li><li>深拷贝</li><li>编写一个通用的事件监听函数</li><li>web端cookie的设置和获取</li><li>setTimeout和promise的执行顺序</li><li>JavaScript 的事件流模型都有什么？</li><li>navigator对象，location和history</li><li>js的垃圾回收机制</li><li>内存泄漏的原因和场景</li><li>DOM事件的绑定的几种方式</li><li>DOM事件中target和currentTarget的区别</li><li>typeof 和 instanceof 区别，instanceof原理</li><li>js动画和css3动画比较</li><li>JavaScript 倒计时（setTimeout）</li><li>js处理异常</li><li>js的设计模式知道那些</li><li>轮播图的实现，以及轮播图组件开发，轮播10000张图片过程</li><li>websocket的工作原理和机制。</li><li>手指点击可以触控的屏幕时，是什么事件？</li><li>什么是函数柯里化？以及说一下JS的API有哪些应用到了函数柯里化的实现？(函数柯里化一些了解，以及在函数式编程的应用，最后说了一下JS中bind函数和数组的reduce方法用到了函数柯里化。)</li><li>JS代码调试</li></ul><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><ul><li>谈一谈 promise</li><li>所有的 ES6 特性你都知道吗？如果遇到一个东西不知道是 ES6 还是 ES5, 你该怎么区分它</li><li>es6的继承和es5的继承有什么区别</li><li>promise封装ajax</li><li>let const的优点</li><li>es6 generator 是什么，async/await 实现原理</li><li>ES6和node的commonjs模块化规范区别</li><li>箭头函数，以及它的this</li></ul><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><ul><li>HTTP协议头含有哪些重要的部分，HTTP状态码</li><li>网络url输入到输出怎么做？</li><li>性能优化为什么要减少 HTTP 访问次数？</li><li>Http请求的过程与原理</li><li>https（对是https）有几次握手和挥手？https的原理。</li><li>http有几次挥手和握手？TLS的中文名？TLS在哪一网络层？</li><li>TCP连接的特点，TCP连接如何保证安全可靠的？</li><li>为什么TCP连接需要三次握手，两次不可以吗，为什么</li><li>为什么tcp要三次握手四次挥手？</li><li>tcp的三次握手和四次挥手画图（当场画写ack 和 seq的值）？</li><li>tcp与udp的区别</li><li>get和post的区别？什么情况下用到？</li><li>http2 与http1 的区别？</li><li>websocket</li><li>什么是tcp流，什么是http流</li><li>babel是如何将es6代码编译成es5的</li><li>http2的持久连接和管线化</li><li>域名解析时是tcp还是udp</li><li>域名发散和域名收敛</li><li>Post一个file的时候file放在哪的？</li><li>HTTP Response的Header里面都有些啥？</li></ul><h3 id="浏览器相关"><a href="#浏览器相关" class="headerlink" title="浏览器相关"></a>浏览器相关</h3><ul><li>跨域，为什么JS会对跨域做出限制</li><li>前端安全：xss，csrf…</li><li>浏览器怎么加载页面的？script脚本阻塞有什么解决方法？defer和async的区别？</li><li>浏览器强缓存和协商缓存</li><li>浏览器的全局变量有哪些</li><li>浏览器同一时间能够从一个域名下载多少资源</li><li>按需加载，不同页面的元素判断标准</li><li>web存储、cookies、localstroge等的使用和区别</li><li>浏览器的内核</li><li>如何实现缓存机制？（从200缓存，到cache到etag再到）</li><li>说一下200和304的理解和区别</li><li>什么是预加载、懒加载</li><li>一个 XMLHttpRequest 实例有多少种状态？ </li><li>dns解析原理，输入网址后如何查找服务器</li><li>服务器如何知道你？</li><li>浏览器渲染过程</li><li>ie的某些兼容性问题</li><li>session</li><li>拖拽实现</li><li>拆解url的各部分</li></ul><h3 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h3><ul><li>对webpack,gulp，grunt等有没有了解?对比。</li><li>webpack的入口文件怎么配置，多个入口怎么分割。</li><li>webpack的loader和plugins的区别</li><li>gulp的具体使用。</li><li>前端工程化的理解、如何自己实现一个文件打包，比如一个JS文件里同时又ES5 和ES6写的代码，如何编译兼容他们</li></ul><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><ul><li>对AMD,CMD,CommonJS有没有了解?</li><li>为什么要模块化？不用的时候和用RequireJs的时候代码大概怎么写？</li><li>说说有哪些模块化的库，有了解过模块化的发展的历史吗？</li><li>分别说说同步和异步模块化的应用场景，说下AMD异步模块化实现的原理？</li><li>如何将项目里面的所有的require的模块语法换成import的ES6的语法？</li><li>使用模块化加载时，模块加载的顺序是怎样的，如果不知道，根据已有的知识，你觉得顺序应该是怎么样的？</li></ul><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><ul><li>使用过哪些框架？</li><li>zepto 和 jquery 是什么关系，有什么联系么？</li><li>jquery源码如何实现选择器的，为什么$取得的对象要设计成数组的形式，这样设计的目的是什么</li><li>jquery如何绑定事件，有几种类型和区别</li><li>什么是MVVM，MVC，MVP</li><li>Vue和Angular的双向数据绑定原理</li><li>Vue，Angular组件间通信以及路由原理</li><li>react和vue的生命周期</li><li>react和vue的虚拟dom以及diff算法</li><li>vue的observer，watcher，compile</li><li>react和angular分别用在什么样的业务吗？性能方面和MVC层面上的区别</li><li>jQuery对象和JS的Element有什么区别</li><li>jQuery对象是怎么实现的</li><li>jQuery除了它封装了一些方法外，还有什么值得我们去学习和使用的？</li><li>jQuery的$(‘xxx’)做了什么事情</li><li>介绍一下bootstrap的栅格系统是如何实现的</li></ul><h3 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h3><ul><li>对nodejs有没有了解</li><li>Express 和 koa 有什么关系，有什么区别？</li><li>nodejs适合做什么样的业务？</li><li>nodejs与php，java有什么区别</li><li>Nodejs中的Stream和Buffer有什么区别？</li><li>node的异步问题是如何解决的？</li><li>node是如何实现高并发的？</li><li>说一下 Nodejs 的 event loop 的原理</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>基本数据结构：（数组、队列、链表、堆、二叉树、哈希表等等）</li><li>8种排序算法，原理，以及适用场景和复杂度</li><li>说出越多越好的费波拉切数列的实现方法？</li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul><li>cdn的用法是什么？什么时候用到？</li><li>浏览器的页面优化？</li><li>如何优化 DOM 操作的性能</li><li>单页面应用有什么SEO方案？</li><li>单页面应用首屏显示比较慢，原因是什么？有什么解决方案？</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>正则表达式</li><li>前端渲染和后端渲染的优缺点</li><li>数据库的四大特性，什么是原子性，表的关系</li><li>你觉得前端体系应该是怎样的？</li><li>一个静态资源要上线，里面有各种资源依赖，你如何平稳上线</li><li>如果要你去实现一个前端模板引擎，你会怎么做</li><li>知道流媒体查询吗？</li><li>SEO</li><li>mysql 和 mongoDB 有什么区别？</li><li>restful的method解释</li><li>数据库知识、操作系统知识</li><li>click在ios上有300ms延迟，原因及如何解决</li><li>移动端的适配，rem+媒体查询/meta头设置</li><li>移动端的手势和事件；</li><li>unicode，utf8，gbk编码的了解，乱码的解决</li></ul><h3 id="三面、四面常问的开放性问题"><a href="#三面、四面常问的开放性问题" class="headerlink" title="三面、四面常问的开放性问题"></a>三面、四面常问的开放性问题</h3><ul><li>你都看过什么书？最近在看什么书？</li><li>用过什么框架？有没有看过什么框架的代码？</li><li>有没有学过设计模式？</li><li>说一说观察者模式吧！能不能写出来？</li><li>你最大的优点是什么？那你最大的缺点呢？</li><li>你大学期间做过最疯狂的事情是什么？</li><li>你除了写博客还有什么输出？</li><li>现在你的领导给你了一份工作，要求你一个星期完成，但你看了需求以后估计需要3周才能完成，你该怎么办？</li><li>平时关注的前端技术</li><li>如何规划自己的职业生涯</li><li>项目过程中，有遇到什么问题吗？怎么解决的？</li><li>最近在研究哪方面的东西？</li><li>请介绍一项你最热爱、最擅长的专业领域，并且介绍的学习规划。</li><li>请介绍你参与的印象最深刻的一个项目，为什么？并且介绍你在项目中的角色和发挥的作用。</li></ul><h3 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h3><ul><li>你为什么要学习前端？</li><li>你平时的是怎么学习前端的？有什么输出？</li><li>你觉得自己最好的项目是什么？</li><li>身边比较佩服的人有什么值得你学习的？你为什么没有跟他们一样？</li><li>同事的什么问题会让你接受不了</li><li>压力最大的事情是什么？</li><li>和同学做过的最好的项目？</li><li>身边的朋友通常对你的评价是什么</li><li>喜欢什么样的工作氛围</li><li>如何看待加班</li><li>有没有对象</li><li>意向城市</li><li>其他的offer</li><li>为什么要录取你？</li><li>大学里花费时间最多的三件事情</li><li>周末都会干什么？</li><li>未来职业规划</li></ul><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ol><li>面试的时候不要表现出自己想创业。敲黑板。</li><li>从来没有看过源码的话，建议从jQuery，zepto这之类的源码入手，后期可以了解Vue，React常见的功能的源码思路和实现。</li><li>项目经验描述的时候不用太太太详细，拣重点的讲。（因为我就一直说一直说，最后面试官评价插不上话评价减分。）</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我接近两个月的校招里，这里的很多知识点都是从别人的博客、面经一篇一篇的抠下来的，这是前人给后人铺好的路。前端的知识点其实说多也不多，只是太杂，所以我没有整理的特别详细。我之所以以这样的形式分享而不是以面经的形式，主要是有需要的同学们能够“拿去即用”，也是整理一下我原来的笔记。</p><p>呀，身边的人都好强，继续学习。[抱拳]</p>]]></content>
    
    <summary type="html">
    
      面试专用
    
    </summary>
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="面经" scheme="http://yoursite.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
</feed>
